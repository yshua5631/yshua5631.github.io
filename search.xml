<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring源码系列 - IOC和DI]]></title>
    <url>%2F2021%2F06%2F20%2Fspring-ioc%2F</url>
    <content type="text"><![CDATA[对于一个系统的使用者来说，源码就是一个黑盒，不需要关心太多. 正如陀螺仪之于手表，集成电路之于CPU一样，仅仅需要了解这个系统可以做什么，以及这个系统不可以做什么就可以了. 背景 IOC DI 背景为什么需要读源码？ 搞清楚目的和动机，往往比做什么和怎么做更重要. 先说结论 对于我们大多数人来说，不需要读源码或者说读了没什么用. 换言之，我们在读任何源码之前，要问一个问题，为什么要读它? 如果我们需要读源码，基本上就是下面两个大的理由 为了源码而源码 因为别人看了，我们也要看 为了装X或面试 …. 为了解决某个问题 代码运行的时候遇到报错，需要跟踪源码，这种情况很少见，如果出现这种情况，只能说明这个框架是做的还是不够好. 吸取源码的一些思想和设计思路，应用到自己的项目中 读源码的姿势 读源码和读一本武侠小说或者宏观经济学没有大的区别，因为源码和书本质上都是信息，读源码就是萃取信息的过程。 不同的阅读目的，需要用不同的姿势。这里的目的就预设为：吸取源码的一些思想和设计思路，应用到自己的项目中 小说的主题和源码的初衷一本书肯定有一个或者某几个主题，比如歌颂爱情，追求真理。 框架的源码也是的，就Spring来说是为了简化Java开发 - 说起来是简单的，但实现起来并不简单。 小说的线索和源码的设计原则和策略就拿天龙八部来说，它的主线可以是侠义，恩仇，爱情。然后爱情这块就分为三个主人公的分线。Spring源码也可以认为有几条主线:IOC，AOP，POJO, 模版. 这些是Spring的起点和基石，贯穿了Spring的方方面面. 小说的结构和源码的的模块设计小说可以分为几个章节，每个章节大概讲了什么，每个章节的编排顺序是什么。同理，源码可以分为几个模块，模块之间的关系是什么？ 小说的细节和代码的细节里面会有一些观点，然后为了证明这些观点会有事实和逻辑。同理，源码模块里的一些方法会有一些技术细节，比如if,else, try, catch, synchronized, 某个数据结构，或者某个事件的的触发. 所以在这里我们可以得出一个结论：如果读源码二话不说闷着头就跳进入到方法的细节里，这是不对的，是错误的方向. 看书读后感和看源码读后感小时候记得往往要写个什么观后感，现在想想这个事还是挺重要的。看一本书，可以看到作者传递的思想和价值主张(value proposal),得到某个启发，某个思维模型或框架，或者某个精彩的案例和论证,或者优雅的遣词造句，这些是对写作文有帮助的. 看源码也是，举个命名方面的例子，Spring在定位Bean的过程中涉及到AbstractRefreshableConfigAplicationContext类， 这个类名就很长，由5个单词组成, 一般而言，项目中很少取这么长名字来给类命名. 所以Spring的作者传递了这样一个思想：能清楚的表达设计意图是最重要的，其次才是长不长的问题。 心态如果用大口吃烤串的心态去看书和读源码，很显然是没有效果和收益的。现在大多数人比较浮躁，看东西讲究快和多，讲究快本身没有问题，但快了之后，质量就会下降。所以看经典框架的核心模块，要以喝茶的心态来看，也就是《思考，快与慢》里提到的”系统2”. 重要的的东西根据二八法则，一本书里只有20%的东西是重要的，看书不是越多越好，而是看少而精的书，那么源码也不例外，不需要阅读很多框架的源码，也不需要阅读一个框架的所有源码，那如何找到这20%？这是另外一个话题 IOCIOC想要讲的故事 IOC - Inversion of Control, 中文是控制反转， 不管是中文还是英文，从字面上很难理解它的意思, 这与我随便说个词语”依赖变换“没什么区别。 让我们切换一个角度，看看在代码层面IOC意味着什么. 现在有类A和类B，传统的做法是类A依赖于类B，IOC的做法是，A不要依赖于B, 要依赖于B的抽象AbstractB. 比较一下前后的变化 A -&gt; 具体的B A -&gt; AbstractB -&gt; (某种方式指向) 具体B 这种变化让人想到了什么？AbstractB像是一个中介，隔离了A和具体的B. AbstractB侧重描述做什么，具体的B侧重于描述怎么做。所以可以得出一个结论: IOC真正的内涵是将做什么(what)和怎么做(how)隔离开了, 可以认为做什么 是某个企业几十年不会变的核心概念和流程, 怎么做 为了达成某件事的手段是多样的，现在世界本身也是如此，付款的方式有现金和手机支付。所以如果一个复杂的系统没有基于IOC, 那么这个系统没有未来，如果一个系统基于IOC，这个复杂的系统才有演化的可能. 对于IOC，我们有这样的肖像刻画 将做什么和怎么做隔离出来了 - 总感觉做开发的天天无脑的念叨隔离就可以了…. 符合依赖倒置原则 符合好莱坞原则 - 体现在对象实例化的过程中 对于开发者来说，IOC在框架层面是标配，就好比汽车有个ABS系统一样，如果现在买辆车，如果没有防抱死系统，那真的是很奇怪. 有哪些框架支持IOC功能？ Spring算一个 - Spring提供了很多功能，我们可以只使用其中的IOC功能 .net的Autofac HK2 - 轻量级的IOC框架， 如果没有上述框架，只能手写了 研究Spring IOC的切入点 要研究一个东西，可以有很多角度，但最好是遵循简单这个原则。 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("defaultconstruct/user.xml"); User user = (User) context.getBean("user"); var test = 2; IOC 时序图 DIDI 时序图 未来]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统行为之警卫局 - 登录和授权]]></title>
    <url>%2F2020%2F11%2F22%2Fauth%2F</url>
    <content type="text"><![CDATA[在现实生活中，身份识别无处不在。 去银行取钱，得带上银行卡。 去公司上班，得带上门禁卡。想访问一个网站，需要先注册，才能访问其内容。任何一个系统，无论是软件系统，还是真实的现实世界的组织，都需要对人进行识别，然后才能决定这个人能干什么。 背景 什么是登录和授权 如何进行登录和授权 登录和授权相关的实践 登录和授权的未来 背景登录和授权是一个软件系统里最常见的行为。还记得在第一家公司使用过一个ERP系统，登录进去只能看到自己所属的模块.如今应用多了，一个企业内部，可能有专门的财务软件，也有可能有外部购买的软件，基于时间就是金钱，效率就是生命的原则，在一家公司内部，如何统一管理用户的账号，在一个地方登录了系统A, 在另外一个地方可以直接登录系统B，成为一个企业必须解决的问题（SSO）.我要登录极客时间，有好几种方式，但最省时的方式肯定的是第三方登录，点击微信图标， 唰唰几步就完成了登录，而不是重新注册一个账号，输入电话，电子邮件。这也体现了用户至上的设计理念。 换句话说，没有人喜欢复杂和繁琐的东西。简单，简单，还是简单. 什么是登录和授权登录和授权是两件事，要分开说. 什么是登录登录是指一个主体可以进入系统S的行为. 这里的主体可以是人或者是一个物体，系统S可以是软件，也可以是指一个组织以下是一些登录的例子 打开一个web，输入用户名和密码 - 这个是最常见的行为，也是所有验证模型的雏形. 张三刷门禁进公司 插入银行卡，输入密码取钱 登录的形式 输入用户和密码 输入用户和密码，再加上n重验证(比如验证码，或者回答一个私密问题) 按指纹 面部识别从这里看出来，登录这个行为隐藏了一个主题：更简单的方式追求更高的安全 什么是授权授权是指一个主体进入系统S之后，它在系统S里面能做什么. 这里的授权是广义上的授权，和之后讨论的oAuth的概念稍微有点不一样授权的例子如下 登录一个电商网站之后，可以下单买东西 进入公司内部，可以做在自己的座位上，不能坐在别人的座位上。 登录进入一个ERP系统，我是销售部门的人，只能看到销售模块，不能看到财务模块. 授权这个行为表明了主体在系统S里面基于特定的约束，只能做特定的事情. 如何进行登录和授权单系统的登录和授权 单系统登录设计原则 密码需要设计复杂度 存在数据里的密码需要加密 最好加一些额外的验证 - 比如验证码 能以最小的成本平滑的过渡到SSO 单系统授权设计原则 权限表能很好的添加或者删除权限 有专门的工具来维护权限的添加和删除 多系统登录和授权相关规范下面是一些有关登录和授权的规范，我之所以称它们为规范是为了便于方便讨论。 因为地方会称这些规范是个协议，或者是个框架，或者从字面上看是个语言，这样概念太多，会让人迷糊不清。规范本质上是一种约束。 它描述了 一个系统可以做什么 一个系统不可以做什么 一个系统如何做某件事 SAMLSAML（Security Assertion MarkUp Language）顾名思义是一个与安全和断言有关的规范。 下面引用了维基百科的定义 SAML is an open standard for exchanging authentication and authorization data between parties, in particular, between an identity provider and a service provider. SAML is an XML-based markup language for security assertions (statements that service providers use to make access-control decisions). 维基百科回答的大体还是准确，但一会说这是个标准，一会又说这是一个语言，所以很乱。从这里也可以看出, SAML主要解决这样一个问题: 如何在IDP和SP之间交换验证和授权的信息？SAML有三个角色 Client - 张三 Identity Provider - 微信 Service Provider - 极客时间 基于上面三个角色， SAML大体的workflow是 Client 访问 Service Service 将 Client 导向到 IDP Client 登录成功 IPD将Client导向到 Service Service验证用户登录成功 Client在浏览器上可以正常访问资源 OAuthOAuth是一个关于授权的标准，它不做验证。 OAuth 2.0 is the industry-standard protocol for authorization. OAuth 2.0 focuses on client developer simplicity while providing specific authorization flows for web applications, desktop applications, mobile phones, and living room devices OAuth的的角色 Resource Server - 资源，比如房子 Resource Owner - 资源的拥有者，比如这个房子是属于张三的 Authorization Server - 有个组织负责给张三配房子的临时钥匙 Client - 李四 OAuth的故事大概是这样的：张三有一家公司，李四想去张三的公司仓库里取货，但张三不能把真正的钥匙给李四，只能委托一个机构给李四一把临时的钥匙，这把临时的钥匙只能去仓库，不能去财务室. 这把临时钥匙是不记名的，换句话说，如果王五抢劫到这把临时钥匙，也是可以去仓库取东西的. 更技术一点就是说 授权服务器如何采取一种简单又安全的方式给Client生成access token? OAuth的花式生成access token的方式 授权码 简化模式 密码模式 客户端模式 OpenId Connect(OIDC)OpenId Connect是一个专注于身份验证的规范. OpenID Connect is an interoperable authentication protocol based on the OAuth 2.0 family of specifications. It uses straightforward REST/JSON message flows with a design goal of “making simple things simple and complicated things possible”. It’s uniquely easy for developers to integrate, compared to any preceding Identity protocol. 从上面的描述可以知道 OIDC也包含授权功能，因为它是基于OAuth2.0, 但我们要记住OIDC的主业是认证，认证是它的价值主张, 授权只是它的副业.如果说授权最终的产出是access token, 那么验证最终的产出就是id token. 基本上，只要拿到了这两种token, 就可以在各个软件系统中为所欲为的横着走了. OIDC的角色 End User - 张三 Relying Party - 相当于OAuth的Resource Server。 比如极客时间 OpenID Provider - 身份认证服务，类似于SAML中的IDP。 比如微信 ID-Token - 包含身份认证信息的JWT UserInfo Endpoint - 获取用户的昵称和头像等信息 OIDC的大体的WorkFlow是这样的 RP 发送认证请求给 OP OP 让用户来验证 用户提供正确的身份验证 OP 生成 id token 和 access token给RP RP 根据 access token 发送一个获取用户信息的请求. RP 获得用户的信息 相关框架Spring Security Spring Shiro KeyCloak 登录和授权的相关实践如何设计一个权限系统这里的权限系统是指一般意义上的权限：主体对资源能执行什么样的操作？ 比如张三可以文件执行写操作.所以权限设计是为了解决这样一个终极问题 主体在什么样的条件下可以对资源执行什么样的操作， 而且随着用户的增加，添加权限的操作尽可能的简单和更安全。 一些权限模型 ACL - 基本的思路是：对一个文件A需要配置张三读写权限，文件B李四需要配置写权限 这种配置是符合直觉的，但是随着用户量的增加，需要一个一个的配，很繁琐. DAC (Discretionary access control) - 是基于 ACL的扩展。 它引入了组和给其他主体授权的概念 张三可以具有对文件A读写的权限，张三属于销售组，所以销售组也可以对文件具有读的权限 文件A的拥有者张三同时也可以将文件A读的权限赋给李四，这样是自主的核心要义。 Windows和Linux权限是基于DAC的。 Windows的权限设计不够灵活，比如说“读取和执行”是一个权限，但其实是微软将读取和执行两个权限打包在一起了，然后让用户选择允许和拒绝 Linux的的权限设计充分体现了细粒度，互斥的组合的思想。比如说权限只有三种，读，写，执行，一个文件有三大类用户: 拥有者，所属组，其他人。每大类用户有7中权限，所以总的权限组合是777 MAC (Mandatory access control) - 相比于DAC, MAC强调的是更安全。张三和李四同属于销售组，但是张三是经理，李四是员工，所以张三和李四对文件A是有不同对访问权限的，这个问题DAC就解决不了. MAC引入了信息敏感度这个概念, 也就是引入了一个新的维度. 要配置资源的信息等级 要配置用户主体的信息等级 核心的财务文件只有经理级别的财务人员才能查看，但是经理级别的销售人员就不能查看. RBAC (Role based access control) - RBAC的核心概念是：主体，角色，资源 一个销售角色有很多权限，比如查看合同，创建客户，删除客户等等，只要一个人是销售，它就具有这些权限 角色是权限的集合，而组是用户的集合 ABAC (Attribute base access control) - ABAC相比于其他模型是它的表达力是最强的. 如果要表达张三上午可以对文件进行读取操作，那么上述所有模型都无能为力。ABAC可以表述为: X在Y条件对Z执行A操作, 这里的X,Y,Z,A都是可以自定义的. 来自北京的张三在上午10点钟可以读取服务器上80端口的内容。 这段表述够复杂了吧，ABAC就可以干这事情。已经有点声明式编程的味道了. 操作系统是如何存储用户信息的？ 协议 X.500 - X.500是基于OSI的目录访问服务，众所周知，OSI现在已经被淘汰. LDAP（Lightweight Directory Access Protocol） - LDAP是一个基于X.500的目录访问的协议，但它更简单，而且支持TCP/IP，这对互联网访问非常重要. 实现 Active Directory - 这是LDAP在windows上的实现，它的层次结构依次是：域(Domain) -&gt; 组织单位(Orgnization Unit) -&gt; 群组(Group) -&gt; 用户(User) 一般来说，AD适合在内网中的C/S架构 OpenLDAP ADFS - ADFS是一种跨网络的身份认证方案，也就是用户账户和应用程序位于不同的网络. 相比于传统的AD, ADFS可以穿透不同的网络. Azure AD - 是基于云上的身份认证和授权方案。 它支持Rest风格. 具体一点就是通过api可以拿到access token和id token, 这是开发者最关心的信息. 它支持多重身份验证 它支持多租户，租户和租户之间的数据是彻底隔离的 它不是主域控制器 登录和授权的未来 无论是SAML, OAuth 还是 OpenId Connect, 我希望将来只有一种认证和授权协议, 姑且命名为XAuth. 它有如下特征 生成和解析token是简单的 token是安全的 形成规范 .net, java以及前端有成熟框架和社区支持，且这些框架被大多数公司所使用. 所有技术无论是原则，模式，还是方式，统一是大趋势。 我们不想要两个或者多个。可以看到一些例子 前些日子, .net5发布了，统一了.net core, mono. Spring Cloud想统一解决分布式领域内的所有问题，并形成规范. 这也就是为什么我对认证和授权协议会有统一的构想的原因。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议之保密局 - Https]]></title>
    <url>%2F2020%2F11%2F17%2Fhttps%2F</url>
    <content type="text"><![CDATA[安全，这件事情无处不在。我们不希望自己的个人信息被泄漏。我们不希望自己的银行卡密码被盗取。我们不希望自己的一言一行被监控，我们希望能有个人的隐私.作为用户获取信息的入口之一 - 浏览器，它是如何保证信息安全的？ 浏览器安全的主角Https登场了. 背景 什么是Https Https的机制是什么？ 安全和Https拾遗 背景1994年，网景公司在TCP/IP协议栈上创建了一个传输加密层: SSL(Secure Socket Layer), 这是一个原始规范，但没有发布。1995年2月，修订了规范，并发布了SSL 2.0.1996年，SSL 3.0发布, 得到大规模应用.IETF 觉得SSL有硬伤，只能加密HTTP，为什么不能加密所有的应用层协议呢？IETF在SSL 3.0的基础上， 重新命名和设计了这个协议，取名为TLS。1999年1月, TLS 1.0 发布.2006年4月, TLS 1.1 发布.2008年8月, TLS 1.2 发布.2018年3月, TLS 1.3 发布. 什么是HttpsHttps是一种网络协议, Https = Http + SSL/TLS. HTTPS是为了 身份验证 - 张三给李四发消息，如何保证李四知道这个消息是张三发送的？ 信息泄漏 - 张三给李四发消息，如何保证信息不泄漏给王五？ 信息篡改 - 张三给李四发消息，王五拿到信息进行了篡改，李四如何知道这个信息有没有被篡改？ 以上三个问题可以规约成一个问题： A给B发消息，如果保证只有通信双方知道消息的内容？ Https的机制是什么在讨论Https的原理和机制之前，先确定几个大的前提 操作系统是正常的 - 不要使用盗版操作系统 浏览器是正常的 - 不要下载被改造过的浏览器 CA中心是正常的 - 就好比一个市政府不能是假的. 人是有可能犯错的 - 有时候脑子短路，会有误操作. 服务端的私钥是不会被窃取的 引入这些大前提的目的是 方便讨论问题，否则会钻进一些牛角尖。 说明没有绝对的安全。 Https机制的核心理念 非对称加密实现证书的传输 对称加密进行数据的传输 Https的两大阶段 证书验证 客户端发起连接请求 服务端返回证书 客户端验证证书是否合法，如果不合法则给予警告和提示 数据传输 证书验证合法之后，客户端生产随机数，用服务端的公钥加密随机数 将随机数发送给服务端， 服务端根据随机数选择对称加密算法。 服务端对要返回的内容进行加密 中间人攻击 - Man In The Middle中间人攻击是客户端和服务端在通信的时候，通信被第三方劫持，而客户端和服务端都意识不到第三方的存在。一个基本事实: 证书只有服务端能拥有. 在基于上面提到的几大前提的基础上，要防止中间人攻击的问题就变为： 如何让客户端知道这个证书是正常的？ 客户端如何验证证书的有效性的？ 验证域名, 有效期 验证根证书来源是否合法 验证证书是否被篡改 验证证书是否被吊销 黑名单方式 - 定期从CA下载名单列表，效率高，但不实时. OCSP方式 - 在线验证。效率低，但实时性高. 证书的三种类型 DV - 验证域名 OV - 验证域名，企业信息 EV - 验证域名，企业信息，律师函等等. 安全和Https拾遗下面是近些年遇到的一些与安全相关的话题 大概4年前左右的样子，公司将全部站点升级为Https. 以前数据库密码是明文保存的，现在已经改成密文了. 代码库里不同的branch有不同的权限. 一些数据库连接字符串在github仓库里是密文保存的，下载到本地之后是明文. 网站有段时间账号攻击，加了验证码作为第一道关卡。 GDPR - 对于欧洲的用户，用户同意之后，数据才能保存到Salesforce里]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议之万维网摇篮 - Http]]></title>
    <url>%2F2020%2F11%2F09%2Fhttp%2F</url>
    <content type="text"><![CDATA[凡是与电脑打交道的人，每天必然会用浏览器，只要用了浏览器就需要输入一个网址。这个网址的样子是这样的： “http://”, 没错，它就是这篇文章的主人公。它是如此的熟悉，以致于我们会忽略它的存在.它的前世今生到底是什么样子？ 背景 http发展历史 未来 背景1965年8月24日，Ted Nelson发表在美国计算机协会（ACM）上的论文，用到了词语“hypertext”. 这里的超文本和我们现在说的超文本内涵是不一样的.1989年， 当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 Mesh。 在随后的1990年项目实施期间被更名为万维网（World Wide Web）. 它有四个部分组成 HTML - 一种用来表示超文本的格式 HTTP - 用来传输超文本的协议 网页浏览器 - WorldWideWeb， 显示超文本的软件。可以打开地址，体验一下第一款网络浏览器. 服务器 - CERN httpd. 从这里我们可以看到 HTML是一种文档格式。再看看现在的Html5，这种变化是相当相当的巨大. Http不干别的，就是用来显示文档的. 第一个网页浏览器 第一个web服务器 这里没有JS. 换句话说，不能和网页有交互. 这里没有CSS. 换句话说，浏览器的内容没有那么美 我们应当记住这个时间点，在这个时间点上出现了好多第一。而且也应该知道，出现这些东西是简单的和朴素的。这个世界是变幻莫测的，有哪几股力量导致了http, html 变成了今天这个样子？ Http发展历史Http/0.9 - 小学生 Http/0.9在1991年发布。 它是简单的。 它只支持 get方法。 只能返回Html格式的文件.也没有错误码，如果发送错误，返回一个错误的Html就可以了. Http 0.9真的可以说是技能单一。 Http/1.0 - 中学生Http/1.0在1996年5月发布，它是http0.9的升级版。 它的能力相比0.9就强多了 支持状态码 支持多种格式的文档返回类型 缓存 - Expires, Pragma Keep-alive - 需要显示指定。 默认是短连接 Http头 新的Http方法 - HEAD, POST。 至此，前端开发中最常用的Get, Post方法已经全了 Http/1.0 存在的问题 连接无法复用 - 每次通信都是遵循打开连接，接受数据，关闭连接这个过程。这就导致了效率非常低下 Http/1.1 - 大学生1997年处，Http/1.1发布. Http/1.1的特性在整个Http历史上是革命性的，如同Jquery之于前端, Spring之于Java.来看看Http/1.1可以做什么 持久连接 - 默认支持长连接 pipelining机制 - 客户端同时按顺序发送多个连接，服务端按顺序返回多个响应 新增Http方法 - OPTIONS, PUT, DELETE, TRACE, CONNECT Host头 - 支持一个物理机部署多个站点。 新的缓存机制 - Cache-control，etag 断点续传 - content-range， 隐含了分而治之的思想。 分块传输 - transfer-encoding: chunk， 隐含了分而治之的思想。 Http/1.1的问题 线头阻塞（Head of line blocking）- HOLB Http2 - 初入职场2015年，Http2发布。 Http2与Http/1.1的不同是, Http2在应用层面解决了线头阻塞的问题. 为了解决这个问题，等待了15年.Http2它有什么能力？ 多路复用 用一个连接进行数据的收发。看到这里有些朋友是不是眼熟？Node和Redis都是用一个线程来专门做特定的事情。 创建一个连接，或者创建一个线程都是有开销的，既然如此，就用最少的连接或者线程好了。 一个场景：如果在一个连接上，同时想获取js, css, html文件应该怎么办？ 以前的做法是获取完了js文件，然后再获得css文件。一个很自然的想法是将这文件切割和剁碎。然后拿到碎片之后再进行组装，从使用的角度来看，就是并发. 流和帧 一个流可以理解为一个请求 流可以设置优先级 流由多个帧组成。 每个帧是标记自己属于哪个流。 就好像每个人知道自己属于哪个组织. 帧是基于二进制编码的。 在传输过程中，帧和帧是乱序的。 基于二进制 头部压缩 基于HPACK算法 在客户端和服务端两端维护各自的字典 服务器推送 Http2是否真的完美无缺？ 当然不是。 Http2只是部分的解决来队头阻塞的问题. 为什么呢？因为TCP本质上是要保证顺序的，一个发送的包丢了之后，是无法收到后续发送包的响应的。 所以根据木桶原理，即使上层再怎么拆，怎么分，再怎么捣腾也没有.一场风暴正在酝酿着. Http/3 - 职场老油条既然TCP是队头阻塞的元凶，那么把TCP干了不就可以了？这不可以，因为大多数互联网的设施是基于TCP, 简单的说就是TCP历史包袱较重. 当然了，也不可以对TCP直接修改，这些修改都牵涉到操作系统内核的更新。所以再TCP身上动念头的思路可以停止了. 换一个思路，可不可以从UDP身上下手？让UDP发100个包，它不会多发也不会少发，但它要是包丢了，它也不管. UDP身上的行为比较简单，可以基于 UDP做些事情.于是, QUIC登场了。 QUIC的初衷是在UDP的基础上，实现和TCP类似的功能，而且要消除TCP的缺点。所以QUIC的整体战略定位还是蛮高的.QUIC协议支持： 建立连接的优化 拥塞控制的优化 更好的多路复用 前向纠错特性 连接迁移这个五个特性的最终目标都是为了一个字：快.那么Http/3是什么？ Http/3是HTTP/2 over QUIC. 在2018年10月28日的邮件列表讨论中，互联网工程任务组（IETF） HTTP和QUIC工作组主席Mark Nottingham提出了将HTTP-over-QUIC更名为HTTP/3的正式请求，以“明确地将其标识为HTTP语义的另一个绑定……使人们理解它与QUIC的不同”，并在最终确定并发布草案后，将QUIC工作组继承到HTTP工作组。在随后的几天讨论中，Mark Nottingham的提议得到了IETF成员的接受，他们在2018年11月给出了官方批准，认可HTTP-over-QUIC成为HTTP/3 未来]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议之靠谱邮差 - TCP]]></title>
    <url>%2F2020%2F11%2F03%2FTCP%2F</url>
    <content type="text"><![CDATA[网络的信道是不稳定的，有时候施工队伍一不小就把光缆给挖断了，也有时候也有可能网络上连接太多了，导致弱网环境， 这些冰山一角的事情，充分说明了网络是不可靠的. TCP设计的初衷是保证数据能在网络上进行可靠的传输。 光缆都断了，数据还怎么可靠传输呢？下面，开始我们的探索之旅. 什么是TCP TCP要解决什么问题 TCP是如何解决这些问题的 拾遗 什么是TCPTCP全称是Transmission control Protocal, 是一个工作在传输层上的协议. 它只关心数据如何可靠和有效的到达目的地，但不关心数据如何到底目的地。 TCP要解决什么问题TCP要解决的问题是数据如何可靠和有效的到达目的地。 可靠 如果发送的包丢了，应该如何处理？ 数据包是有顺序的，如何保证接受方拿到的包也是有顺序的？ 有效 如果服务端比较忙或者比较闲，客户端应该采取什么样的策略来发送包？ TCP就是为了解决这三大问题而存在。 但这三大问题会衍生一些子问题. 回到一开始的那个问题： 光缆都断了，数据还怎么可靠传输呢？答案是光缆断了，数据没法可靠传输。网络不可靠是一个事实和大前提， 在网络不可靠的大前提，TCP尽可能的保证可靠的数据传输。一个不太恰当的比喻： 张三娶了一个漂亮老婆，这个老婆有点花心和不可靠。 但即使老婆花心和不可靠， 那日子是不是还得照样过？所以张三就想了各种办法，比如平时对老婆好点，让她收收心，平时也查查她的手机，看看是否有可疑的聊天记录。张三所做的一切就是让一个本性不靠谱的女人行为上稍微靠谱一点. TCP是如何解决这些问题的一个完成的TCP过程是建立连接，收发数据，释放连接. 前置知识 TCP的包是没有IP地址的，那么是IP层的事情. TCP连接是点对点的，也就是说一个TCP连接对应的是两个端口. ACKn代表着到目前为止，对方序号n-1的之前的数据都正常收到了，也代表期望对象下次发送序号为n的数据. 建立连接建立连接是为了进行可靠的数据传输做保证。就好比去拜访一位朋友，得事先打个招呼告知一下.TCP建立连接是通过三次握手的策略来保证的。三次握手保证了 客户端知道自己和对方有接受和发送的能力 服务端知道自己和对方有接受和发送的能力 第一次握手是保证了服务端知道自己有接受能力，对方有发送能力.第二次握手是保证了客户端知道自己有发送和接受能力，服务端有发送和接受能力.第三次握手是保证了服务端知道客户端自己有发送的能力，客户端有接受能力. 从这里可以看出，二次握手是不能保证服务端知道自己是否有发送的能力，客户端是否有接受的能力.四次握手也可以，但画蛇添足了. 收发数据客户端给服务端的发送数据包，数据包丢了怎么办？ 如果快递员给别人送货，货物弄丢了，快递员的选择很简单重发一个或者赔偿, TCP也不例外， 这就是TCP的重传策略. 对于重传，我们需要考虑以下问题 什么时候进行包重传？ 重传哪些包？ 如何进行重转 服务端返回 ACK 包的机制 客户端发送了1, 2, 3, 4, 5 总共5个包，服务端收到了1, 2，会返回ACK3, 然后收到了4(此时没有收到 3)， 那么服务端应该返回什么？ 还是ACK3. ACKn的真正含义是服务端已经收到了n-1个连续的包, 并期望客户端发送第n个包. 假设存在一种上帝策略X, 这个策略可以让客户端及时的发送服务端所需要的包，且不重复.围绕上面三个问题，看看下面四种重传策略是如何逼近这个上帝策略的. 超时重传 超时重传的思路是：设定一个定时器，如果在规定时间内没有响应，则重发数据包. 超时重传的思路是朴素和直观的。但超时时间应该怎么定？如果时间间隔太长，则发包的效率太慢，如果时间间隔太短，会导致响应包还没收到，就重发了，就导致更多的重发。目前主流的策略是超时重传的时间（Retransmission Timeout）略大于包往返时间（Round-Trip Time）。 实际情况是 ，RTT是动态的，所以相应的 RTO也是动态的. RTO的计算规则相对复杂，具体公式可参考RFC 6298. 这里顺便说一下，这个公式的一些参数是长期实践得到的，无法从逻辑上推导出来，有点类似于现在的机器学习现状，参数调一调，发现可以得到预期的结果，但没有办法解释为什么，简单的说就是两眼一抹黑，完全靠不断的尝试. 快速重传 快速重传的思路是从多次发送包的响应值中找规律。 如果客户端发送1，2，3，4，5份数据， 1先到了，ack返回2，然后2因为某种原因没收到，3到了，ack返回的还是2，4，5也到了，ack还是2. 至此，客户端收到了三个ack=2的包，就知道2出问题了。于是重发2，因为3，4，5都收到了，ack返回的是6. 上面这个例子是一个比较理想化的例子。我们需要面两个选择：究竟是重发2，还是后面的3，4，5也要重发？ 重发2 - 如果3，4，5里面没有丢包，重发2是最完美的选择。 但 3，4，5里面如果有丢包的，那么还得重发丢失的包 重发2，3，4，5 - 如果3，4，5里面没有丢包，重发3, 4, 5是一种浪费。 快速重传仅仅解决了定时器效率的问题，但没有解决什么时候应该发2，什么时候该发3， 4，5这个问题. SACK - Selective Acknowledgment SACK的思路是服务端告诉客户端一个大体的全貌，我当前已经收到了什么，我还没收到什么。所以这也是一个比较自然的思路. 具体细节可参考 RFC 2018 SACK需要客户端和服务端同时支持 SACK会占用发送方的资源。试想一下，如果黑客劫持了服务端，给客户端发送不正常的SACK包，那么客户端就会每次都要计算服务端哪些包收到了，哪些包没有收到. D-SACK - Duplicate SACK D-SACK的核心思路是告诉客户端哪些数据是被重复接受了。具体可见RFC 2833. 通过D-SACK, 我们可以知道 丢失的包是发送的包还是ACK包，如果丢失的包是ACK包，客户端就不要无脑重发服务端已经收到的包 先发的包后到的情况. 客户端给服务端发送数据包是按顺序发送的，服务端是如何保证拿到的一些数据包是有序的？客户端给服务端发送数据包的过快怎么办？前置知识 滑动窗口 - TCP是每发一个请求，就会有一个响应，如此循环。 这明显效率太低了。有没有可能我一次发送多个请求， 然后只需要一次响应就可以了？这个思路直觉上是可行的. TCP的滑动窗口是为了协调发送方和接收方的速度. 这本质上是个生产者-消费者模型。生产者发送速度过快，消费者接受不了怎么办？增加一个中间缓存带。滑动窗口其实就是一个缓存带.流量控制是TCP提供的一种机制，是为了匹配收发双方的速度.以服务端接受数据为过程为例 网卡接受到的数据会放到内核缓冲区 内核缓冲区会将相应的信息挪到某一个TCP连接的接受缓存区(接受窗口就是接受缓存区) 然后应用程序会从接受缓冲区读取数据客户端发送数据如下 应用程序将数据放到发送缓存区（发送窗口就是发送缓存区） 将发送窗口的数据挪到内核缓冲区 内核缓冲区的数据从网卡发送出去 拾遗 发送缓冲区和接受缓存区是针对一个TCP连接的。整个内核缓冲区是针对整个操作系统的 TCP头里有一个字段叫 Window代表窗口大小 窗口的大小是有接受方的窗口大小决定的. 如果客户端到的TCP window的值为0, 那么意味着服务端处在水深火热当中，没能力处理数据了。那么客户端就不会发送数据了。但是万一过会，服务端又复活了呢？ TCP是用Zero Window Probe技术，发zwp包给服务端。 窗口为0会引起死锁 糊涂窗口综合症(Silly Window Syndrome) - 如果接受方的可用窗口太小，只能容纳几个字节，发送方还在为了发几个字节需要带上很多的附加信息，显得很耗带宽资源，得不偿失。有点像服务端对客户端说我的仓库没空间了，你不要大老远过来送一些牙膏牙膏牙刷了，等我空间大了，你再送些大件过来. 如果是服务端导致的糊涂窗口综合症，那就关闭窗口 如果是客户端导致的糊涂窗口综合症， 使用Nagels算法。核心思路是等可用的窗口变大了再发数据 Nagle算法默认是打开的，对telnet或ssh交互性比较强的程序，需要关闭这个算法。 流量控制和用塞控制的区别是什么？ 流量控制是针对发送者和接受者之间的策略，侧重于微观，并不知道网络的整体情况。 拥塞控制是为了从宏观保证整个网络畅通的 流量控制为拥塞控制做了一小部分铺垫，但这还不够，拥塞控制还需要额外的策略. 关闭连接直观上说，建立连接是三次握手，关闭连接应该是更简单，直接一句GoodBye就完事。但事实并非如此，根本原因TCP是全双工。TCP建立连接之后，双方是可以同时收发数据的，那么就意味着连接需要两个通道. 所以关闭连接就变成了如何处理两个通道.两个通道都没有数据收发才是最关闭连接的标志. 关闭的真正的含义是要关闭两个通道一起关闭，但前提是两个通道都要确认没有收据收发.释放连接可以用客户端和服务端任意一方发起。下面是客户端是发起释放连接的过程 客户端发送FIN，代表要释放发送通道 服务端收到客户端的FIN, 知道客户端没有数据要发送了. 发送ACK给客户端, 代表我同意你的请求. 但此时服务端还不能关闭连接，因为服务端可能还有数据要发送给客户端. 服务端觉得直接没有数据要发送了，就发送一个FIN请求关闭连接 客户端发送ACK给服务端，同意服务端的关闭连接请求.服务端收到ACK之后就关闭连接，客户端在等待2MSL时间之后，没有收到回复，就关闭连接. 整个网络发生了阻塞怎么办？想象一下每次过节开车回家，怎么知道回家的路是一路通畅的呢？看地图上面的交通线路状况是不是绿色，如果是红色，则代表路况拥堵. 整个网络也是出现拥堵和通畅两种情况。在节假日的时候，交警应对这种情况有好几种方法 车主上高速的时候，收费站限流，只开几个闸口 车主上高速的时候，收费站完全关闭，让车主改选国道 已经在高速上的车流，交警会尽可能的疏导让它们快速的去目的地. 网络拥塞发生的时候，有如下策略 慢启动 慢启动的核心原理是第一次发包的时候发一个包，第二次翻倍，以此类推。发包的数量是指数级增长。当发包的数量超过某个阀值的时候，采用拥塞避免算法。 可以看出慢启动的策略还是有点粗鲁，不够灵活。 拥塞避免 拥塞避免和慢启动有类似之处。当一次发送包的数量超过某个阀值的时候，那么下次发包的数量，就呈现线性增长。相比于指数增长，这个增长很慢了。 拥塞发生 当网络发生阻塞的时候，会发生丢包，既然发生了丢包，那么就要重传 发生超时重传的时候，会导致又要重新进入慢启动的过程 发生快速重传的时候，TCP认为你还能收到三个ACK包，说明网络还可以啊。于是将发包的数量降到一半，而不是像超时重传，将发包的数据量降到1. 然后进入快速恢复算法 快速恢复 快速恢复的核心是用另外一种策略来控制发生包的大小。 这个策略先不详细展开。 至此，介绍了拥塞控制的四个算法。这四个算法的都遵循的原则是 尽量的发包，而不是不发. 这个四个算法的思路都是围绕着“什么时候发多少包”展开的.这一点很像高速收费站，什么时候允许多少车辆进去. 拾遗TCP粘包 客户端在发送包D的时候，服务的滑动窗口容纳不下这个包，所以只能接受一部分包D1，一个包就被拆开了。 客户端在发送D1和D2两个包，服务端接受的时候，接受到一个包，包含D1和D2, 服务端无法鉴别 D1和D2. 上面的这种现象是由TCP的特性决定的。 我们可以给这些现象命名。但这些是问题吗？如果是问题，TCP应该背这个锅吗？ 答案是：TCP不背这个锅，TCP不解决这个问题。如果这是个问题，应该由应用层去解决. TCP存在的问题 TCP设计的时候有个大前提：网络的包的丢失是因为网络堵塞引起的. 这个大前提直接决定了TCP的设计方向. 但其实网络包的丢失可能是 移动基站的弱网环境 防火墙针对性的丢包]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程语言概述]]></title>
    <url>%2F2020%2F10%2F31%2Fprogramming-language%2F</url>
    <content type="text"><![CDATA[众所周知, 计算机这个行业是不断发展的。 编程语言就是其中之一，要么是出现新的语言，要么是出现这个语言的特性升级。 其他领域，比如法律和医学， 知识更新迭代的速度远比不上编程领域.让我来沏一杯茶，闲聊一下编程语言这个老生常谈的话题. 编程语言历史 什么是编程语言？ 编程语言的种类 设计一门编程语言需要解决什么问题？ 编程语言的未来 编程语言历史 1842年：第一个程序 Ada Lovelace 在笔记本上写了一些计算机指令一样的东西，后来被公认是世界上的第一道计算机程序，只是那时计算机还没有问世。 1957年: FORTRAN - 第一个程序员可以使用的程序 John Backus 发明了 FORTRAN，这是第一门真正意义上有程序员在使用的编程语言 1959年: COBOL Grace Hopper 发明了第一门企业级的编程语言，叫作“common business-oriented language”，简称 COBOL 1964年：BASIC 1970年：Pascal 1972年: C语言 - 为Unix的出现奠定了基础 1980年: Smalltalk - 第一个支持面向对象的语言 1983年: Ada 1983年: c++ 1986年: Objective-c 1987年: Perl 1991年: Python 1993年: Lua 1994年: PHP 1995年: Ruby 1995年: Java 1995年: Javascript 2001年: C# 2009年: Go 2010年: Rust 2012年: TypeScript 2014年: SWift 根据公开的语言排行榜，排名前十的语言都是70年代以后诞生的语言. 这里面, C语言在底层领域是霸主，Java在应用领域独占鳌头, Python是数据处理领域的翘楚, JS是Web开发领域的不二人选. 什么是编程语言？编程语言和中文，英文都有相似的地方，比如要符合一定的语法，但又稍许有些不同，比如人和人完全可以用汉语交流所有问题， 但计算机却没有这样一个语言能解决所有问题.编程语言是给开发者使用的一种模型工具. 它符合一定的规范， 以某种方式解决了计算机特定领域的问题。 这种方式背后的思想包括且不限于 抽象 抽象的目的是为了提供统一的方式来处理现实中的概念和行为 一个例子：在国家层面，不管男女老幼，都统一叫做公民，公民这个词就是一个抽象，在计算机领域可以表现另外一种名字: ID 隔离 软件开发的根本目的是为了控制复杂度。而分离关注点是其中的一个有效方式 一个例子： 国家以秦岭淮河为分界线，将中国的地域分为南方和北方。 隔离抽象和实现 隔离重要和非重要 隔离不变和变化 组合 这个世界上大多数系统是基于还原论的，软件系统也不例外。 一个系统如果是可以还原的，那么就是可以组合的. 一个例子：不同的县组成了市，不同的市组成了省，不同的省组成了国家. 编程语言的种类编程语言的种类远多于数据库和操作系统的种类，正如武林中有各种各样的门派一样，编程语言也有很多门派. 这些门派之间也是口水不断和相互鄙视的。要了解一个编程语言的价值，可以从下面的角度来思考 解决了什么问题 是否符合用户的认知模型 过程式编程 过程式编程的核心概念是结构体和过程（也可以称为函数） 侧重于描述先做什么，后做什么，符合人的自然思维 缺点 函数是全局的，没有访问控制. 项目规模变大了，代码会比较混乱，容易形成意大利面条的形式. 面向对象编程 面向对象的价值主张是一切皆对象。 对象包含状态和行为. OO的鼻祖是SmallTalk， I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning – it took a while to see how to do messaging in a programming language efficiently enough to be useful)….OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP. 从上面这段面向对象设计的初衷我们可以看到 对象类似网络的一个独立的节点 对象隐藏了内部的状态 对象和对象之间是通过消息方式来交互协作的 其中对象是一个独立的节点在不同的场景下，它可以是：组件，服务或者一个独立的系统.要实现以上特性，必须做好下面的事情 抽象 - 需要不断的总结和归纳名词，也正应了命名是计算机的两大难题之一 隔离 - 在良好的抽象基础上，才能进行很好的隔离. 这是一种分解思维. 基于以上特点我们可以编写任何复杂的系统. OOP是一种思想，OOP程序不一定要用OOP语言来写 这个世界上花花草草，各色人等都可以用名词来表示，所以围绕名词以及名词的行为来表达这个世界是很自然的事情。因为我们上学的时候无论是学语文还是学英文都是要从区分名词，动词，形容词等开始的。 所以围绕名词来描述和表达问题对人的认知来说，是丝滑般的自然. 一些符合面向对象思想的例子: 猫是一种动物。 很多时候，我们要回答这个东西是什么 审批流程，员工A想要请假，小组长需要审批，上面的经理也需要审批，这个流程是可以画出一个协作图. 可以想象一下函数式编程如何处理这个问题 反对OO的声音 对象是有状态的. 想要引用一个对象的行为，就必须把它相关的对象都引用进来 你想要香蕉，但是得到的却是拿着香蕉的大猩猩和整个丛林 拾遗 相比于继承，优先使用组合是业界主流。 面向对象和关系型数据库是好朋友 面向对象诞生在单核时代. 一个类有私有和公开的部分，私有的部分是针对维护者，公开的部分是针对使用者。在使用者眼中看来，公开的契约或者接口就是全部的功能， 使用起来能降低使用者的认知负担. 以前的老式收音机，会有音量，调频，开关三个键，这三个键就是全部的功能，满足用户的所有需求. 函数式编程 函数式编程的价值主张是一切皆函数. 函数从语义上来说，强调的是行为。 它有两个核心原则 Stateless - 简而言之就是函数内部不保存任何状态. 求解1+2+4，在过程式编程中，先算出1+2=3，作为一个值保存在变量中，然后再加上4得到最终结果7。 求解1+2+4，在函数式编程中，函数接受输入1，2 返回结果3，然后将返回结果3和数据4作为输入传函数，最终返回结果7 Immutability - 输入的数据是不能被改变的. 有一个复印的函数，输入是原始照片，输出是复印件，函数执行完毕之后，原始的照片必须是完好无损的. 所有的函数式编程都必须遵守这两个核心原则. 函数式编程也是声明式编程的一种. 函数式编程用到的技术 尾递归优化 map &amp; reduce 管道 - 函数可以按顺序组合. 其思想来自Unix, 如果将这种组合思想应用到宏观领域就是服务的编排 递归 - 从直觉上定义和描述问题. 暗含了”做什么”的思想 柯里化 - 将一个函数的多个参数分解为多个函数. 暗含了分解和隔离思想 高阶函数 - 将函数A作为参数传入去，然后包装成另外一个函数再返回. 这里体现了分层和组合思想. 这是一个很重要的特性, 因为任何问题是可以分层次解决的. 一些符合函数式编程的例子: 斐波拉契数列: f(x)=f(x-1)+f(x-2) 对一组数据进行加工，排序，然后分组，然后过滤，然后转换，最终得到结果. 可以想象一下面向对象是如何处理这个问题的 函数式编程的优势: 没有状态就没有伤害，很契合高并发场景. 重构代码的时候可以基于Copy的方式. 反对函数式编程的声音 保证不变性是有代价的 对某个下标的数组元素的修改，就需要复制整个数组. 总结函数式和面向对象都有各种的粉丝， 两波粉丝也是口水不断, 都是拿各自的优点来攻击对方的缺点.正如我们前面提到的，这个世界上没有所谓的优点和缺点，只有特点.脱离问题和场景谈优缺点都是耍流氓. 当今的软件开发主要是在工程领域，而不是科学领域. 科学领域主要是研究理论和算法. 工程领域主要是解决现实中的业务问题. 根据二八法则，高水平的开发者只占20%, 一般水平的开发者占其中的 80% 。既然是工程问题，那么肯定有一大批开发者，这些开发者的水平也是参差不齐的。所以就需要一些相对简单的方式来满足大多数开发者写业务逻辑。而面向对象这种模型满足来80%的开发群体. 但这个理由还不是最充分的. 如果软件的规模很大，量变就会产生质变. 就需要简单的方式来写业务。只有简单符合直觉的东西，才是可读的，可理解的，然后是可维护的. 面向对象满足着一点。这是一个事实型的结论。 市面上的大型软件没有一个是基于函数式构建的. 写代码和写文章没有本质的区别. 写文章也要遵循一定的机构，比如总分总。写代码也是，但更严格. 代码是写给人看的，然后顺便可以执行. 设计一门编程语言需要考虑什么问题？如果要实现一门现代编程语言，需要考虑哪些方面的问题？ 从语言的能力的角度， 它需要有 类型系统 如何表达基本类型？ 整型，字符型，布尔型. 如何表达非基本类型？ 类和函数谁是第一等公民？ 流程控制 顺序，选择，循环 常用的算法和数据结构 顺序存储和链式存储。 比如数组，链表 字典 集合的各种操作。 比如sort, sum, filter… 进程和线程 如何处理高并发问题 异常处理 如果程序遇到非正常情况， 应该如何处理？ 时间 任何语言都必须提供良好的API支持时间。包括时区转换，时间格式化等操作. 网络 如何收发消息？ NIO还是AIO? 正则 这个是大多数语言都会内置的功能。 正则表达式是一种声明式语言 文件 各种各样的文件操作和解析. 数据库 如何连接数据库 如何读写数据库 内存的分配和回收 如何合理的利用内存？ 编程语言和架构是什么关系？编程语言和架构不是一个层次上的事物。从设计重要性的角度来看， 架构的选择 &gt; 编程语言的选择. 编程语言不会决定架构的选择，但是会对架构的选择产生一些影响。 当选择一门编程语言的时候，选择的往往不是这门编程语言本身，而是选择的基于这门语言的框架和生态. 就好比，张三娶了李四，娶的不仅仅是李四，还包括李四的家庭 编程语言的未来]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议大观园]]></title>
    <url>%2F2020%2F10%2F27%2Fnetwork-protocol%2F</url>
    <content type="text"><![CDATA[我们这个世界为什么存在这么多语言？如果世界上只有一种语言，那么每个人都不需要学英语了，想想都很美.相传在远古时候，人们想建造一座高可通天的塔，可以彰显自己的名气，这样也可以防止人们走散之后仍然可以找到回家的路。上帝一看，这可不对，于是设法改变了不同人的口音，这样大家就无法交流，通天塔的建造就此搁浅. 人和人之间说话是通过某种语言来沟通的，比如英语或者汉语。计算机和计算机之间通信也不例外，也需要语言，但这个语言和人类说话的语言稍微不一样，计算机和计算机之间会有不同的功能，不同的功能需要不同的语言，这里的语言往往称为协议. 背景 什么是网络协议? 如何设计网络协议 有哪些网络协议 背景试想一下，如今的互联网由哪些因素组成? 我们大概会想到 线缆 网络设备 - 交换机，路由器，网卡 运营商 - 比如中国电信 防火墙 终端设备 - 可以是PC, 手机或者任何的智能设备 终端设备上的操作系统和应用软件 上面有提到计算机和计算机通信需要协议，那么这个协议到底存在什么地方呢？ 答案是操作系统.网络协议的数量有很多，这里聊聊一些常用的的协议. 什么是网络协议网络协议是计算机和计算机之间为来完成特定功能进行通信的某种约定.现在我们知道谈到网络协议有两个概念必须要讨论： OSI和TCP/IP 先说说OSI, OSI是ISO组织制定的一个模型，用来指导网络协议设计. 很明显这个模型是分层的，至于为什么要分层？这个问题本质上和软件要分层是一样的，之前有专门讨论“分解”这个话题. OSI模型的大概分为七层 应用层 - 用户直接接触到的，比如电子邮件客户端 表示层 - 电子邮件有特定的格式，怎么转换成标准的传输格式呢？ 会话层 - 发送端什么时候建立连接，什么时候释放连接？ 传输层 - 这一层只关心数据包如何可靠达到目的地，比如这个包是不是完整的 网络层 - 这一层负责认路，比如有几条路，如何更快达到目的地 数据链路层 - 将数据帧转换为0/1比特流 物理层 - 将0/1比特流转为高低电平 这个模型很难说它是基于哪一个维度进行拆分的。我们对人进行分类，可以基于性别分类：男人和女人，也可以基于地域分类：南方人和北方人， 这很符合直觉。 但我也从中隐约看出了两条线索 信息是如何变成高低电平？“Hello World” -&gt; 统一的字符编码 -&gt; 二进制 -&gt; 高低电平 信息是如何又快又好的达到目的地? 正如我们所知, OSI并没有称为主流协议，为什么？不实用，或者说不接地气. 后来的事情，大家都知道了, TCP/IP成为主流.TCP/IP这个名字顾名思义是TCP协议和IP协议，但这个是错觉, TCP/IP是一个协议大家族，是互联网协议的统称, 我们知道的Telnet, ICMP，SSH都属于TCP/IP协议.但我们更想知道为什么TCP/IP协议胜出了？或者说TCP/IP协议做对了哪些事情？ 有以下几个因素 开放性 - TCP/IP是由IETF讨论决定的，IETF是一个任何人都可以加入讨论的组织，这充分证明了群众的力量是强大的. 实用性 - TCP/IP先有实现，然后才有规范。也就是规范发布出来的时候，已经有操作系统实现了这个协议。而不是像OSI整天在天上飘 TCP/IP 也是基于分层的 应用层 传输层 网络层 数据链路层 如何设计一个网络协议网络协议不可能从天而将，所以需要人来制定，既然是一种沟通工具，那么自然这个工具要符合又快又好的标准了. 快 让网络的传输变快 好 安全 最好一种协议能解决多个问题，如果不能解决多个问题，那么就聚焦于一个问题 简单 可以扩展 有哪些网络协议 应用层协议 HTTP DNS PingPING是应用层直接使用网络层ICMP的一个例子，它没有通过运输层的TCP或UDP. 一个系统允许Ping取决于两个因素，任意一个被禁止就不能被Ping 内核参数 防火墙如果Ping被禁用，我又想知道远程主机是否还可以连接，那怎么办？ 可以通过tcping这个工具来测试某个端口是否开放. nslookup - 用来测试域名是否可以正常解析 Telnet - 用来进行远程登录 SSH - 安全版的Telnet 传输层协议 TCP - 让数据可以可靠达到目的地 UDP - 牺牲正确性换取效率的协议 网络层协议 ICMP traceroute ARP 数据链路层协议]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>协议</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网大事记]]></title>
    <url>%2F2020%2F10%2F27%2Fhistory-of-internet%2F</url>
    <content type="text"><![CDATA[在之前我有提到，人类社会发展有一条线索是关于信息的，人类社会的发展史就是一个信息数量越来越多，信息连接越来越快，信息载体越来丰富的历史.想想古时候，将军打了胜仗，如何将捷报传给皇帝呢？只能通过马，每个几十公里，会有一个驿站，这已经是当时的最快方式。试想一下，如果那个时候能打个电话给皇帝，这效率该有多高啊。 现在的马拉松比赛就是为了纪念菲迪皮茨这样一位古时的英雄. 希波战争波斯人和雅典人在离雅典不远的马拉松海边发生的，雅典人最终获得了反侵略的胜利。为了让故乡人民尽快知道胜利的喜讯，统帅米勒狄派一个叫菲迪皮茨的士兵回去报信。菲迪皮茨是个有名的“飞毛腿”，为了让故乡人早知道好消息，他一个劲地快跑，当他跑到雅典时，已上气不接下气，激动地喊道“欢……乐吧，雅典人，我们……胜利了”说完，就倒在地上死了。 要是有了现在的通信技术，一切都会变的不一样。 互联网发展至今，已经有几十年历史了，如果它渗透到人们生活的方方面面，以致于人们认为互联网的存在就像水存在一样自然. 以史为鉴，可以知兴衰. 把时钟拨回到从前，看看之前的通信和互联网历史. 1839年：真正投入使用营运的电报线路于在英国最先出现 1850年：首条海底电缆横越英吉利海峡，把英国及欧洲大陆连接起来 1865年：麦克斯韦发表论文《电磁场的动力学理论》，预言了光的电磁波理论. 1895年：意大利人马可尼首次成功收发无线电电报 1969年：阿帕网是第一个使用包交换技术的网络 1969年10月29日，斯坦福大学和加州大学洛杉矶分校的计算机首次连接了起来, 它们是互联网上的第一台主机. 在网络上发送的第一条消息应该是“Login”，但据报道，在发送字母“g”的时候，连接断了 1969年：Unix 1971年：电子邮件出现. 电子邮件于1971年首次被Ray Tomlinson开发出来，他也是那个决定使用“@”符号将用户名和电脑名字（后来变成了域名）分开的人 1971年：古登堡计划和电子图书 第一次有人想让图书变成电子书 1972年：CYCLADES 法国于1972年开始建立自己的类似于阿帕网的项目. 创新的想法：主机只负责数据的传输而不是网络本身 1973年：跨大洲的连接和电子邮件的普及 阿帕网第一次跨过了大西洋，和英国伦敦的一所大学连了起来。同一年，电子邮件占所有网络应用的75% 1974年：TCP/IP协议的诞生 1975年：电子邮件客户端 电子邮件第一次有了转发和回复功能 1977年：电脑上的调制解调器 1978年：电子公告栏系统（BBS）- 网络上的黑板 1978年：垃圾邮件的诞生 Gary Thuerk给加利福尼亚的600个用户发了垃圾邮件 1979年：MUD——最早的多角色游戏 MUD是完全基于文本的虚拟世界，将角色扮演游戏、互动、剧情和网上聊天结合在了一起 1979年：新闻组（Usenet） 新闻组是一个基于互联网的讨论系统 1982年：第一个表情 1982年Scott Fahlman在一个笑话之后用了一个:-） 1983年：阿帕网上的计算机通过TCP/IP交换数据 阿帕网开始通过Vinton Cerf开发的TCP/IP协议交换数据。数以百计的电脑都连到了交换机上，服务器这一名字也是83年开始出现的. 1984年：域名系统（DNS） DNS最大的意义是让IP地址有了一个名字，这样人们会更容易记住这个名字. 1985年：虚拟社区 Stewart Brand和Larry Brilliant于85年2月开发。它开始是为了让全球的读者和作者进行交流，并且是一个开放的但是却是“有文化底蕴的、高智商的”人的聚会点 1986年：协议战争 OSI PK TCP/IP, 最终OSI倒下. 1987年：互联网在成长 1987年，互联网上有近三万台主机。以前的阿帕网协议只能限于有1000台主机，但是采用了TCP/IP标准后，使得有更多的主机变成了现实 1988年：IRC——互联网中继聊天 实时聊天的先驱 1988年：第一次恶意的攻击 第一个主要的互联网蠕虫是1988年发行的。它被称为“莫里斯蠕虫”，作者是Robert Tappan Morris，导致了大部分地区的互联网的中断。 1989年：美国在线（AOL）诞生了 - 最大的上网服务提供商 1989年：万维网（WWW）的推出 1990年：第一个商业性的拨号上网ISP 1990年：万维网协议尘埃落定 1991年：第一个网页诞生了 前端开发者应该非常激动 1991年：第一个基于内容的搜索协议 - Gopher 1991年：MP3成为标准 1991年：第一个摄像头 它部署在剑桥大学的计算机实验室，其唯一目的是监视一个咖啡壶，使实验室用户可避免将时间浪费在一个空的咖啡壶上 1993年：Mosaic——第一个图形化浏览器 1993年：白宫和联合国的网站上线了 1994年：网景浏览器 1994年: 中国正式接入因特网 用得是一根64K的国际专线 1994年: 国内第一个Web服务器 1994年5月15日，中科院高能物理研究所，建立了国内第一个Web服务器，推出中国首套网页，用于介绍高科技发展情况，其中一个栏目还提供包括经济、文化、商贸等方面的信息，后更名为“中国之窗” 1995年：互联网进入商业领域 这一年出现了两家公司，一个是Echo Bay, 另外一个是Amazon 1995年：雅虎成立 1995年: 中国第一个互联网接入服务商 1996年: 国内第一家网吧 1996年：第一个基于网络的服务HoTMaiL出现 1997年：博客出现 1997年：Netflix 1998年：第一个不是靠传统媒体报道的新闻 - 克林顿/莱温斯基的性丑闻 1998年：Google - 现在还活得很滋润 1998年：基于互联网的文件共享 1999年：利用闲置的资源进行分布式计算 该项目是一个通过互联网利用世界范围内的300多万台计算机进行计算的分布式计算项目，一旦计算机处于屏幕保护状态，那么意味着计算机就处于空闲状态了，这样就可以利用这些计算机的处理能力了。该项目目的是通过分析天文数据来探索外星球智能的迹象 2000年：网络泡沫破裂 2001年：维基百科发布 2003年：网络电话 2003年：MySpace成了最流行的社交网络 2004年：Web 2.0 - 这也是前端领域的一个转折点 2004年：社会化媒体和Digg Digg对传统的发现和产生网络内容的方式产生了革命性的影响，新闻和网站连接全都是由社区投票民主决定 2004年：Facebook 2005年：YouTube 2006年：Twitter 2007年：网络电视 Hulu在2007年首次推出，与美国广播公司、全国广播公司和Fox合资，目的是使流行的电视节目可以在网上观看 2007年：iPhone 2008年：网络选举]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统的正确性 - 事务及相关]]></title>
    <url>%2F2020%2F10%2F25%2Ftransaction%2F</url>
    <content type="text"><![CDATA[事务这个词在开发世界里默认是和数据库绑定在一起，但其实其他领域里也有事务这个词，比如会计事务所，律师事务所，不同领域的事务所指的意思是不一样的。 这里主要聊聊 什么是事务 为什么是事务 如何实现一个事务 总结 什么是事务在不加任何限定的情况下，这里的事务默认是指数据库领域的的事务，如果是其他领域的事务会特别说明。 数据库事务一般来说，如果一个数据库支持以下四个特性，我们说这个数据库支持事务 Atomic 一个事务由一系列操作组成，这些操作要么全部完成，要么不做。从系统的角度来看，这个事务只有完成和未完成两种状态，不存在完成一半这个说法。 换句话说，做事不要半吊子或者说做事有始有终. Consistent 在事务执行之前和事务执行之后，整个系统的状态是符合逻辑的。 一致的概念往往是指A和B的状态行为一致，就比如军训的时候，我们要求大家的步伐一致。 但是数据库的一致性可不是这个意思，它的一致性更多的是从系统的角度来说逻辑上的正确性。 比如张三给李四转账20快，那么张三的余额就少了20块，李四的余额就多20块，这个从逻辑上来说是正确的。 一致性就是指系统的正确性. Isolation 事务A和事务B在执行的过程中，是不会互相干扰对方的执行结果的正确性。 事务隐含了如下事情 事务的操作对象是存储单元（表） 事务是并发的 锁是在并发过程中保持正确性的一种方式 事务的隔离级别是效率和正确性之间的权衡 Duraton 事务完成之后数据变保存在存储单元里，并不能回滚。简单的说，就是覆水难收，落子无悔. 事务如果完成了一半，是可以回滚. ACID给人的第一感觉这四个特性是平等的，正如古人所信奉的仁，义，礼，智，行，这五者是并列的。但ACID并不符合MECE原则， 更像是为了凑ACID这个单词. ACID正确的描述： 从原子性，并发，存储三个维度采取策略，完成正确性这个目标 这里的ACID这四个特性并没有涉及到具体的技术概念，换句话说，这是一种思想和策略，既然是思想和策略，那么意味着可以应用到宏观和微观层面. 分布式事务将上述事务的四大特性应用到分布式领域就是分布式事务.在设计分布式事务的时候，有两大默认约束条件 网络故障 通信延迟 Spring事务Spring事务是为了支持数据库事务而提供的统一编程接口. Redis事务Redis事务是由一系列命令组成，它满足: 原子性 - 所有命令要么全部执行，要么不执行。 但Redis的原子性是伪原子性，为什么呢？因为只要有一个命令执行报错，它并不会回滚，所以Redis遇到命令执行失败，会继续执行下去，简单的说, Redis在原子性这方面更像是一个二愣子，一顿操作猛如虎. 隔离型 - 一个事务执行完毕，另外事务才会执行。这个更像是serializable的隔离级别. Kafka事务Kafka的事务机制是保证生产者和消费者的操作在逻辑上是一致的 软件事务内存Http事务HTTP事务在这里顺便提一下，它与上面所说的事务没有什么关系.一个Http事务是由一个Http响应和一个Http请求组成.Http事务是一家之言，有时候会让人和联想到数据库里的事务，但只要记住Http事务和别的事务没有任何关系. 为什么是事务事务本质上是一种策略和机制，是为了保证系统的正确性，所以事务的出现是必然的. 如何实现一个事务如何实现分布式事务? 策略 两阶段提交协议 第一阶段：事务管理器发生CanCommit消息给资源管理器，每个资源管理器在本地执行操作但不提交（有点类似于正式打仗之前实战演练一遍），然后发送Yes/No给事务管理器， 代码本地操作成功或者失败。 第二阶段：事务处理器根据Yes/NO有如下操作Yes - 发送DoCommit给各个资源处理器，执行剩下的操作，执行成功发送 HaveCommited给资源处理器No - 发送DoAbort给各个资源处理器，本地执行成功的操作根据事务日志做回滚，回滚到一开始的状态，就好像什么都没发生一样， 然后发送HaveCommited给资源处理器. 事务管理器接受到资源管理器的HaveCommited， 整个事务执行完毕。 MysqlSql的InnoDB事务就是基于两阶段提交的 两阶段提交协议有点类似准备打仗的时候，司令问部下，你们都战术都演练好了吗？ 部下回答都演练好了，那么司令的回复是开打，如果有部下的回答是还没，那么司令的答复是不打. 两阶段提交协议的缺点 事务管理器必须等所有资源管理器等操作完毕才能继续下一步的操作，所以两阶段提交协议不太适合高并发场景 如果事务管理器挂了，那么整个系统就处于停滞状态 网络发生故障的时候，有些结点接受到DoCommit命令，就会执行操作，有些结点没有接受到就不会执行, 这样就导致数据不一直. 这个问题属于一个通用问题. 注意事项 两阶段提交协议是数据库层面的协议，换句话说，相应的数据库必须支持XA协议，但一些数据库，比如MongoDB或者Cassandra并不支持XA协议, 同样Kafka也不支持. 三阶段提交协议 三阶段提交协议是为了解决两阶段提交协议中的同步阻塞和网络故障导致的数据不一致问题 超时机制 - 在发送CanCommit之后，等待返回结果的这段时间内，有个时间限制，如果超过了这个限制，就放弃本次事务。 如果失败了再重试，而且失败了这个成本和代价是可以接受的，因为没有带来额外的数据损失. 超时时间和重试次数取决于业务本身. 将第一个Voting阶段拆分为CanCommit和PreCommit两个阶段. 不论是两阶段提交还是三阶段提交，它们 是集中式事务管理，存在单点故障的风险 是同步调用 存在数据不一致的风险 TCC（Try-Confirm-Cancel） 最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出 TCC类似于两阶段提交协议，主要应用在业务层面，所以需要TCC框架. 由主业务方发起 不存在集中式事务管理单点故障的问题 本地消息表 本地消息表这个方案是由eBay提出 系统A不直接给消息中间件发送消息，而是将一个事务操作保存到消息表里。 系统A有个后台程序读取这个消息表，将读到的消息发送给消息中间件. 但也又可能发送失败，如果发送失败，接着发。所以系统A有如下特征 消息不会丢失，但可能有重复 消息之间的顺序有保证 系统B作为消费方，会遇到两个问题 丢失消费 - 拿到消息之后，处理到一半机器挂了。 解决方案：使用ACK机制。 如果处理到一半，机器挂了，那么重启之后，还会继续收到同样的消息. 重复消费 - 在本地增加一个已经处理过的消息表，然后判断消息是不是已经处理过. Saga事务 Saga 事务源于 1987 年普林斯顿大学的 Hecto 和 Kenneth 发表的如何处理 long lived transaction（长活事务）论文 一个Saga事务是由一系列子事务组成 Saga事务由两种执行顺序 T1, T2, T3, Tn T1, T2, T3, Tn, Cn, C3, C2, C1 Saga的两种恢复策略 向前恢复: 如果T3执行失败，那么会一直重试T3直到成功为止. 向后恢复: 如果T3执行失败, 那么会执行C3, C2, C1做相应的补偿. 无论是补偿也好，还是rollback也巴，不纠结名词。 这里的补偿大体分为两类 操作上真正的逆向， 比如 T3代表余额增加了10块钱，那么C3代表给余额减去10块钱. 操作上无法逆向，也就是覆水难收. 比如 T3代表火箭发射， 那么在这个时候C3是无法逆向的，T3失败的话，C3意味着召开一个新闻发布会。 Saga的子事务是如何组织的？ 协同式 - 每个子事务都知道整个事务的执行序列。事务和事务之间通过消息进行通信. 相当于一个团队里，每个人都有大局观, 积极主动性比较强. 编排式 - 有一个统一的编排器来统一管理子事务，和协同式是完全相反的思路，类似于一个团队里老大说了算的方式. Saga的缺点 Saga的事务不是隔离的，需要在应用层面采取某种策略和机制来保证. Saga的一些补充 T和C是幂等的 无论执行 T, C还是执行C, T，这种两个操作逻辑上必须是等价的. 基本定理 CAP - CAP定理是在描述发生网络故障(Partition Tolerance)的时候, 一致性(Consistency)和可用性(Availability)不能两全. P - 分区容错性，白话一点，就是网络发生故障了，每个结点会形成一个隔离的区域. 网络一定会发生故障的，这是客观事实。 所以在讨论CAP的时候，我们往往是讨论当P发生时，应该怎么选C和A. C - 在发生网络故障的时候，系统想要获得数据，必须等网络故障恢复，具体一点，用户看到是一个等待页面. A - 在发生网络故障的时候，系统为了让用户不等待，可以给用户相对的可以接受的数据. BASE - Basically Available, Soft State eventually consistency, CAP是一个比较不接地气的定理, BASIC定理是CAP的一个补充。 BA - 基本可用， 这个是主观性比较强的指标。 比如之前一个请求的响应时间是0.5秒， 现在一个请求的响应时间是2秒，那么这个两秒在业务层面是可以接受的。或者牺牲非核心业务和流量的可用性，保证核心业务和流量的可用性. S - Soft Sate, 在不影响可用性的前提下, 允许同一时刻系统的状态存在中间状态. 比如将张三地址从A修改为B，突然发生了网络故障， 一部分机器上已经修改完，另一部分机器上没修改完，这时候不同机器查询张三的地址会得到不同的结果。 我们能不能容忍这种状态？取决于业务本身. E - Eventually Consistency, 继续上面的例子，等网络故障恢复了，所有结点上的张三的地址都为B 总结在上面说了这么多，无论是单机数据库事务，还是分布式数据库事务，还是应用层面的事务，都是为了解决一个问题：执行一系列操作，如何保证一系列操作完成之后，整个系统的状态是一致的？]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之武林盟主 - Spring]]></title>
    <url>%2F2020%2F10%2F20%2Fspring%2F</url>
    <content type="text"><![CDATA[许多年之后，当讨论起Java开发的时候，可以不讨论安卓开发，可以不讨论多线程，可以不讨论流，可以不讨论JVM, 但Spring是一个绕不过去的话题.Spring从诞生到现在已经有20年左右的历史，这个生命不如linux, 但也足够长了.在前端界，还找不到和Spring框架相提并论的框架，Spring的框架在Java领域是没有对手的，可以说找不到竞品，前端至少是React和vuejs两家独大，而且也是最近几年才出来的产物.这篇文章主要闲聊 什么是Spring? 为什么是Spring? 如何实现一个Spring? Spring实践？ Spring的发展 拾遗 什么是Spring?2002年10月, Rod Johnson出版了一版名为《Expoert One-on-One J2EE设计和开发》的书，书中指出了Java EE和EJB组件框架中的主要缺陷。在这本书里，他提出了基于普通Java类和注入依赖的更简单的方案.在这本书发布不久之后，有两位开发者说服了Rod Johnson基于书上的代码创建一个开源基础框架的项目. 2003年三位开发者创建了一个项目, 开发者yann给框架取了一个很有诗意的名字”Spring”.有点类似中国文化里蕴含的一元复始，万象更新的意思.所以Spring是一个框架，致力于简化Java开发 Spring有很多功能，如果不断的去砍掉一些功能，让Spring只具备最核心的功能，应该是 IOC AOP这是Spring其他的功能的基础和起点 Spring当前最新的版本是5.0, 5.0要求的最低JDK版本是8, JavaEE规范是7. Spring的大版本更新至少要基于两个因素 一个最低的JDK版本 特定的JavaEE规范 为什么是Spring?这个问题很简单，在当时从框架层面简化Java开发的只有Spring框架，并没有其他框架，可谓一家独大.就好比创业的时候，选择了一个赛道，然后这个赛道上只有一家企业，等这家企业壮大了，只要不作死，其他企业想进来也没有机会了. 如何实现一个Spring?整体设计目标 Spring框架所有做的事情都可以说是为了一个终极目的: 简化Java开发. 策略 基于POJO的轻量级和最小侵入编程 POJO是简单的，那就说明是容易理解的，而且不含有杂质. DI和面对接口实现松耦合编程 隔离了接口和实现 基于AOP和惯例的声明式编程 AOP是为了隔离了核心功能和非核心功能 惯例是用户熟悉的事物 基于AOP和模板减少样板式代码 模版说明是一致的编程模型，减少重复代码. 战略背后的思想基于上面的策略，可以总结出这些策略背后的思想 符合用户的心智模型 - 简单，熟悉，一致 用户喜欢简单和熟悉的东西. 因为简单的东西和熟悉的东西意味着可理解，可理解意味这可维护 一致的编程模型。 对于类似的东西，不可能用方法A处理事物A, 方法B处理事物B, 而是要用一个统一的方法处理事物A和事物B 隔离 隔离抽象和和具体，抽象代表着稳定，具体代表着不稳定 隔离核心和非核心，核心的东西代表着重要，非核心的东西代表着次要 上面这两大思想可以用来指导架构设计和类库设计. 模块图 Spring容器的三架马车, 三是个好数字，三生万物. Bean, Core, Context为Spring框架奠定了基石 BeanBean是Spring组件核心中核心，正如一部电视剧的主角一样，挪走了主角了，这部剧就没有什么看点了. 正如面向对象编程里，对象是第一核心，剩下的是对象的关系和行为。Spring Bean也是如此, Bean是Spring起点. Bean主要回答了三个问题 如何定义一个Bean 如何创建一个Bean 如何解析一个Bean ContextContext赋予了Bean更丰富的内涵，让Bean活跃起来,变的更有生命力 获得Bean列表 解析资源 发布事件 国际化 CoreCore组件是一系列工具的集合, 它的某些概念与Bean没有直接关系，比如Log功能。Core这个名字其实取的不是特别好，会让人有点疑惑,会让人感觉Core组件就是核心， 核心意味着所有的组件都围绕着Core转，其实并不是，Spring的核心是Bean。拿打仗做个比喻, Bean是冲锋陷阵的士兵，Context是指挥官，协调管理这些士兵, 那么Core是什么呢？更多类似于后勤和伙夫, 从这里可以看出Core并不是核心. 所以把Core理解为Spring的瑞士军刀比较合适, 因为Core能提供某些贴心的小功能. Spring实践？展示 展示一般而言与Web有关，这里的展示意义更加宽泛一点，可以指手机，手表等任何显示设备. 展示层实现策略有两大方向 前后端不分离 前后端分离 数据任何的信息都必须是可以存储的，或者叫做持久化。这样的信息是基本事实，可以给各种方式（比如机器学习）企业的决策提供依据。 数据存储有两大类型 关系型数据 非关系型数据 缓存用户流量增加之后，为了获得更好的用户体验，减轻数据库的压力，需要一个能抗事的家伙. 这个就是缓存. 安全对于大多数系统，必须回答两个问题 这个用户是谁？ 这个用户能做什么？ 消息任何系统都不是孤立的，系统A想和系统B相互交流，有两种办法 系统A调用系统B的接口 引入一个系统M来隔离系统A和系统B, 这样系统A和系统B就完成隔离开了，符合正交的特性。换句话以后系统A即使消亡了，也与系统B没有什么关系. 这个M往往称做消息系统或者消息中间件. 其他系统出了故障，我们希望能快速的去解决故障，而不是两眼一抹黑。换句话说，我们能对系统有掌控。 一般来说有如下方式 日志 监控 Spring的发展Spring Boot Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. Spring Boot不是Spring的功能升级，而是简化了Spring的构建. 使用Spring Boot 没有繁琐的XML的配置 不需要操作Jar包之间的依赖关系 内置了Jetty容器，不像之前要生成一个war包，然后拷贝到特定的jetty目录下. 两个例子 我们知道汽车有一键启动的功能，在此之前我们要掏出钥匙，插入钥匙，启动。 做的事情都是启动，但很明显一键启动完全提高了效率. 做过前端开发的朋友，应该知道create-react-app这个脚手架，可以大大的提搞开发者的效率，Spring-boot扮演的就是脚手架这个角色。 所以Spring boot从整个Spring的历史来看，它很重要，但没有革命性的东西。 Spring Cloud Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems 从这里可以看出, Spring Cloud的定位和明确 聚焦于分布式的问题 提供一致的编程模型. 比如在这里模型下面，服务发现框架可以从容易的从ZooKeeper切换到Consul 所以Spring Cloud的目标是非常宏大, 它不像Spring Shiro是为了解决某个特定的领域的问题, 它要是统一解决分布式领域的各种问题，具体一点就是微服务和云原生相关的问题， 可谓雄心勃勃。 来看看Spring Cloud都提供来哪些工具 Spring Cloud Eureka - 解决了服务注册和发现的问题 竞品 - Nacos, k8s的Service(可以被Istio追踪，纳入servicemesh的管理) Spring Cloud Ribbon - 解决了如何将流量公平得分配到每台机器的问题. 竞品 - k8s的Service Spring Cloud Hystrix - 解决流量过大时， 如何将让流量不再进来的问题. 竞品 - Sentinel, k8s的Istio Spring Cloud Zuul - 解决了流量是否合法，以及流量进来之后去哪里的问题. 竞品 - Kong, k8s的Ingress Spring Cloud Config - 解决了服务配置信息集中管理的问题 竞品 - 携程的Apollo, k8s的ConfigMap和Secret Spring Cloud Stream - 解决了不同服务之间相互通信的问题. Spring Cloud Bus - 解决了不同服务之间如何共享信息的问题 Spring Cloud Sleuth - 解决了如何了解服务全貌这个问题 竞品 - 推特的Zipkin， 大众点评的CAT Spring Cloud Feign - 简化了服务的调用方式 Spring Boot Actuator - 解决了监控程序的问题 竞品 - ZMon, DataDog 拾遗官网中有一幅图，是从Spring boot到Spring Cloud, Spring Cloud DataFlow, 这幅图可以反应这三者之间的时间关系，但同时有个误区，它会给人传达这样一个意思 小学生 -&gt; 中学生 -&gt; 大学生 就是这三者是能力渐进增强的，其实并不是， Spring Boot充其量是个脚手架的角色，和Spring Cloud不是同一个层次的事物，放在一起不好比较. 如果把Spring, Spring Boot, Spring Cloud放在一起，那它们应该是一个什么样的关系呢？ 高尔夫1.4T -&gt; 高尔夫2.0T -&gt; 途观 Spring Boot让Spring变得更快，Spring Cloud让Spring 能力更强]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之B+树]]></title>
    <url>%2F2020%2F10%2F18%2FB-plus-tree%2F</url>
    <content type="text"><![CDATA[做应用开发的朋友大概这辈子不会遇到B+树这个数据结构,它的应用场景更多是在底层。所有做技术的人有时候会面临一些困惑，有些技术或者理论离应用太远，有点曲高和寡，导致了我们会对这类技术丧失兴趣. 但B+树有时候就像一个幽灵一样出现在一些技术文章中，引起你的关注.这篇文章主要是浅谈一下我记忆中的B+树. 背景 什么是B+树？ B+树实践 拾遗 背景要了解B+树先得说说B树, 1972年Bayer和mccreight发明了B树，但并没有说明B是什么意思, B可能代表Balance, Bayer或者Boeing,在这里就不深究B的具体含义了. B树首先它是一棵树，然后它是一颗平衡树，所有的结点都能存储数据。B+树和B树的关系，大体上看就是iPhone6 plus和 iPhone6之间的关系.注意：不存在B-树，这个“-”其实是个连接符，但会让人误解为是减号，如果出现B-tree其实就是B树. 什么是B+树?在讨论B+树之前，我们先要讨论一个阶的概念，就好比有些团队是大团队，有些团队是小团队，阶定义了B+树的规模。满足如下条件的树，是一颗m阶的B+树 根结点的数量在 [2, m] - 大Boss的下属数量范围 正常结点的子结点数量范围是[2/m, m] - 中层骨干的下属范围 一个结点的关键字数量和指针的数量是一致的，一个关键字代表了子结点的极值 - 老板眼里只有核心员工 所有叶子结点都在同一层，叶子结点有指针指向兄弟结点 - 真正干活的只有底层，且底层团结一致 B+树实践B+树与Mysql存储引擎InnoDB 一些基本事实 数据库读取数据是以页(一般而言是4k)为单位将磁盘文件加载到内存（为了方便讨论，一个页上存储一个结点） 普通磁盘加载一个页的数据大概需要10ms(旋转，寻道等操作) 磁盘的顺序读取I/O比随机读取I/O要快10万个量级 内存的读取速度(纳秒级别)和磁盘的顺序读取读取大约是一个量级 查询优化的核心是减少I/O的访问次数 为什么不选择B树？B树的最大特点是是数据分布在所有的结点中，所有在进行范围查找时候，加载多个页的时候，会很耗时 B+树的优势B+树存储数据的特点 叶子节点存放了行数据 所有的叶子结点都在同一层 所有的叶子结点可以形成一个双向链表 叶子结点所在的页分布在不同的磁盘块上 非叶子结点不存储行数据，仅仅为了存储更多的索引键 通过上面的特点，我们可以知道 B+树相比B树很明显的一个特点是树的高度降低了，这样I/O访问就少了. 存储和索引被隔离开来，软件设计的一个原则就是分离关注点回头再看看上面那个B+树的图，它有点像什么？对，像跳表. 跳表的核心思想是让链表具有二分查找能力.所以跳表和B+树的源头思想是一致的. 拾遗 由于B+树的读写会导致逻辑上相邻的数据实际在物理上相聚很远，LSM树(日志结构合并树)是对B+树的改进]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之效率管家 - Redis]]></title>
    <url>%2F2020%2F10%2F15%2Fcache%2F</url>
    <content type="text"><![CDATA[计算机有两大问题，一个是命名问题，一个是缓存失效。缓存在整个计算机体系里无处不在 CPU - CPU缓存 操作系统 - Page Cache 数据库 - 数据库缓存 浏览器 - 浏览器缓存 这篇文章主要是探讨一下缓存的通用问题以及Redis相关问题 缓存概述 Redis历史 什么是Redis 为什么是Redis Redis是如何实现的 Redis实践 Redis的未来 缓存概述什么是缓存 没有看到缓存的通用定义，这里尝试定义一下. 我们有系统X, C, D，这三个系统有如下特征 系统X可以从C和D拿到同样的数据 系统X从C拿到的数据比从D拿到的数据更快 系统C的数据是来自于D 如果上述三个条件满足，那么系统C可以称做为D的缓存. 为什么需要缓存如果系统D满足不了单位时间内多次请求，那么系统C一定是存在的. 原因是 系统C比系统D更快，那么可以提供更好的用户体验. 实现一个缓存会遇到什么问题？ 缓存更新策略 Cache Aside Pattern Write / Read Through Pattern Write Behind Caching Pattern Redis历史2008年，一家意大利公司Merzia推出了一个几个基于Mysql的实时统计系统，但是该公司的创始人Salvatore Sanfilippo对这套系统感到失望，于是自己对这套系统量身定做了一个数据库，且在2009年开发完成, 这就是Redis. 所以这就是比较典型的思路：有了一个痛点，然后才有了一个技术。 而现在不少公司的思路是反的：不管有没有痛点，先用高大上的技术再说.2010年VMware公司赞助Redis, Salvatore Sanfilippo和另外一位开发者加入了VMware公司，全职开发Redis. 所以也是当时的一个痛点问题，改变了作者的人生之路. 什么是Redis我看看官网上Redis的定义: Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker 在我们的印象中，数据库是指MySql, Sql Server，或者Oracle. 所以从这里看得出Redis的定位是多种多样的，可以做缓存，数据库或者消息队列.但有点事实可以确定 相比于Kafka, Redis的消息队列没那么专业 从核心行为的角度来看：Redis是一个支持Key, value的存储系统. 换句话说, Redis的灵魂在于Key,Value. 为什么是RedisRedis是如何实现的整体设计目标 如何又快又好的实现一个Key, Value存储？ 所以可以设想一个最简单的Key, Value的存储， 它应该支持 支持数据的增删改查 数据类型多样 最好支持集群功能 - 或者说任何的框架都应该支持集群功能 原则N/A 模式Redis也是基于Reactor模式来实现的，这一点和Netty类似. 实现 高性能视角 - 对应快这个指标 高可用视角 - 对应好这个指标 分布式维度 主从库模式 全量复制 基于长连接的命令传播 增量复制 哨兵机制 集群 容错维度 AOF日志 - 先更新缓存，然后再更新日志，这样可以得出一个结论：只有日志里有记录，就一定有执行过缓存的命令 。 优点 缺点 内存快照 - RDB 文件 可扩展视角 - 对应好这个指标 数据分片 负载均衡 Redis API Redis用到的数据结构 跳表 布隆过滤器 位图 延时队列 Redis用到的算法 限流算法 GeoHash Redis的实践 Redis做消息队列，业界有日活百万的案例. Redis所在的宿主机挂了之后怎么办？ Redis的未来]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之飞鸽传书 - Netty]]></title>
    <url>%2F2020%2F10%2F12%2Fnetty%2F</url>
    <content type="text"><![CDATA[万物互联是现在乃至未来的趋势. 只要互联就需要网络，不管是无线还是有线。只要牵涉到联网，就牵涉到两台机器上的应用程序之间的通信。 只要是通信，我们就需要又快又好的进行通信。那么应该有一个事物来做这样基础的事情，这样开发者可以专注于写业务逻辑.这个事物就是Netty. 当然Netty不是进行Java进行网络通信的唯一选择，我们自己也可以写一个网络编程框架,但在此刻，它是网络通信框架领域那颗最耀眼的明星,这就是影响力，必须承认它的人气。当我们讨论Java网络编程框架的时候，Netty是一个绕不过去的话题. 让我来沏一杯茶，闲言碎语几句. 背景 什么是Netty? 为什么是Netty? Netty是如何实现的？ Netty的实践 网络编程框架的将来 背景Netty是2004年由韩国人trustin lee开发出来的，同时他也是mina的作者. Netty到现在为止已经由16年的历史，我有理由相信它会继续存活16年 什么是Netty?Netty是 网络编程框架 - Netty解决问题的领域是网络，非网络的它不关心. 异步和基于事件驱动的 容易使用，性能好 - 开发者视角 开发服务器和客户端 - 意味着Netty的使用场景不是单机 为什么是Netty?截止当前这个时间点，github上还有406个问题是open的, 关闭了4810问题, 如果除以16，那么就是1年300个问题，一天一个问题。这也能说明一个问题，网络编程领域的炸弹和坑有很多，不要掉以轻心. 为什么不是JDK NIO?Netty的技能包比JDK NIO多 支持多种传输层协议 解决了粘包，半包现象 流量控制，黑白名单 处理各种个样的异常，比如断连，异常 这让我想起了Jquery, Jquery屏蔽了各种浏览器的差异，提供了一个统一的接口给用户操作DOM. JDK NIO 本身有很多bug, 约为5000个左右.这里说明了两个问题： 开发者直接使用JDK NIO是不明智的选择 开发者开发一个网络编程框架也是一个不明智的选择 Netty是如何实现的？ Netty设计哲学 API让人用起来舒服, 这个是针对使用者的 - 这种舒服应该符合用户的感性和直觉，就好像做西红柿炒蛋的时候，放好鸡蛋之后接着放西红柿。 实现让人舒服 - 这个是针对维护者的. The answer is the philosophy it is built on. Netty is designed to give you the most comfortable experience both in terms of the API and the implementation from the day one. It is not something tangible but you will realize that this philosophy will make your life much easier as you read this guide and play with Netty. Netty是基于Reactor模式实现的 单Reactor单线程 单Reactor多线程 主从Reactor多线程 Netty用到的设计模式 单例 - ReadTimeOutException#INSTANCE 工厂 - ReflectiveChannelFatory 策略 - EventExcutorChooser 装饰 - WrappedByteBuf 模板 - AbstracTrafficShapingHandler 职责链 - ChannelPipeline 构造者 - WebSocketServerProtocolConfig.Builder 观察者 - ChannelFuture#AddListener 从框架设计角度，Netty的核心概念是 Channel - 可以理解为任意两点之间的连接. EventLoop - Channel和EventLoop是多对一的关系，EventLoop和线程是一对一的关系，也就是一个Chanenel接连对应一个稳定的线程, 这样的好处是事件处理是单线程，避免并发问题. Channel通过事件的方式给EventLoop发送消息. EventLoopGroup - 对EventLoop从功能的角度进行分类 bossGroup - 专门用来处理连接 bossGroup连接处理完成之后，要将连接交给workGroup，这到底选择哪个EventLoop呢？Netty使用的是轮询算法. workerGroup - 专门用来处理读和写 ServerBootStrap ChannelHandler和ChannelPipeline ChannelHandler - 事件的处理者，比如做一些业务代码处理 ChannelPipeline - 指定事件的处理顺序，先处理第一件事情，然后处理第二件事件, 换言之就是管理秩序. ChannelHandlerContext - 用于ChannelHandler和ChannelPipeline之间的交互. ChannelFuture Netty的执行流程 - 这个流程的步数是奇数，首尾对称. 启动服务 打开连接 接受数据 数据处理 发送数据 关闭连接 关闭服务 Netty逻辑架构图 Netty功能图 Netty的实践网络编程框架的未来]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>高性能</tag>
        <tag>框架</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[挑战个体极限 - 如何提高一台服务器的性能?]]></title>
    <url>%2F2020%2F10%2F11%2Fperformance-1-pc%2F</url>
    <content type="text"><![CDATA[要提高服务器的性能，正常的思路是 单机堆硬件 - 加内存，换CPU 多个单机组成集群 以上两种思路都是从硬件层面出发的。 我们这里讨论的当有大量请求过来的时候，不从硬件出发，而是从方法论出发，看看有哪些策略可以提升服务器的性能。 两种维度 PPC TPC Reactor Proactor 两种维度组合的场景 连接数量多，请求数量多 秒杀，双十一之类的业务，这类业务一定走分布式这条路 连接数量多，请求数量少 企业的官网 连接数量少，请求数量多 一些中间件，比如数据库连接池，一个数据库连接，是执行SQL的请求可能有几百个 连接数量少，请求数量少 企业的内部系统，比如我司创建学生账号的工具，查看学生学习情况的报表系统. PPCPPC（Process Per Connection) 顾名思义就是一个连接一个进程。这种模式适合连接数不是特别的情况，比如数据库连接数.缺点是 Fork进程是有代价的 父子进程通信比较复杂 TPCTPC (Thread Per Connection) 就是一个连接一个线程. 这种模式可以说是PPC的加强版. 它不需要fork进程，也没有父子进程通信复杂的情况. 但它来来额外的副作用. 这也属于BIO 线程切换是需要代价的 线程之间协作不当就有可能出现死锁 所以这是典型的发明了一个方案，然后制造了一个问题啊. ReactorReactor在前面的博文有隐约提到过，它主要干了两件事 将线程分为两类，一类主线程专门用来接受socket的请求，一类工作线程专门用来处理socket请求 主线程通过某种方式(事件驱动)将请求传给工作线程 - 好莱坞原则 Reactor本质上是同步阻塞I/O Proactor]]></content>
      <categories>
        <category>高性能</category>
      </categories>
      <tags>
        <tag>高性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人多力量大 - 分布式导言]]></title>
    <url>%2F2020%2F10%2F11%2Fdistributed-system%2F</url>
    <content type="text"><![CDATA[一个人抗一个木头会很重，如果两个人一起抗木头，两个人承担的分量会少点，如果三个人呢？那么三个人承担的分量会更少. 换言之，如果从整体上看，三个人的力量要大于两个人现在的应用的数据变得越来越大，业务的流量越来越多了，分布式成为了一个不可避免的趋势。这篇文章主要谈谈 背景 分布式系统的整体设计目标 分布式系统需要解决的具体问题 背景从一个简单的例子开始: 计算一个nxn的矩阵，可以有两种办法 在一台机器上直接计算出来，把结果存放到数据库或者缓存中. 将矩阵划分为四个象限（每个象限为n/2），然后这四个象限分别由四个节点独自处理，处理好的结果最好再后再汇总起来，存放在某个地方. 第一种办法就是单机处理，第二种办法就是分布式处理。第二种办法可以看作分布式处理的最简单模型， 它涉及了 计算 存储 节点之间的通信 - 这里的节点可以是真实的物理机器，或者虚拟机或手机，或者世界上任意可计算的设备 分布式系统的整体设计目标从上面的例子，我们可以看到要计算一个矩阵，我们需要CPU计算，然后保存结果。把这个例子延伸到多台机器上，我们可能会面临如下问题: 分布式计算 分布式存储 分布式通信 - 这是一个很自然而然的概念，毕竟不同的机器是需要通信的. 分布式资源池化 - 不同机器上的 GPU, 内存形成逻辑上性能更强的GPU, 内存. 将上面这四个问题领域合成一个大问题就是： 在某种资源的基础上，通过某种通信方式，进行某种计算，把计算的结果存储在某个地方，然后对外提供一个服务。 这个结论受极客时间上的某位专家的启发. 本着站在巨人肩膀上的原则，将上面的结论和我之前提出的又快又好的指标进行整合 分布式系统的整体目标和远景就是：如何又快又好的实现这个大问题？ 分布式系统需要解决的具体问题节点之间的通信问题 直来直往 - 想要和谁说话，直接找那个人. 这就是RPC问题 专职中介 - 想和谁说话，找专门的中介就可以了。 这就是消息队列问题 一个集群中的节点管理和互相协作的问题 国不可一日无君 - 一个集群中的leader节点挂了，如何产生一个新的Leader节点, 这就是分布式选举问题. 共商国事 - 如何制定一个国家政策得到大家的认可？在分布式领域就是共识问题。 国家是有秩序的 - 文明有礼，排队买票. 一个集群中的资源，在某个时间窗口只允许特定节点访问，这就是分布式互斥问题. 有始有终 - 一个人做事最好不要半吊子，要么不做，要么完成。在分布式领域，这就是分布式事务问题. 分布式资源管理和负载调度 单体调度 两层调度 共享状态调度 分布式数据存储 分布式缓存 分布式高可靠 负载均衡 流量控制 故障隔离 故障恢复]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的I/O模型]]></title>
    <url>%2F2020%2F10%2F09%2Flinux-IO%2F</url>
    <content type="text"><![CDATA[I/O顾名思义就是输入输出，I/O设备可以指网卡，键盘，打印机等，在这里为了方便讨论，I/O专门指网络设备.之前也看过不少专门讲I/O的帖子和文章，其中有不少帖子有误导的嫌疑，比如打一些不恰当的比喻，所以我有了一种想重新梳理一下I/O模型的冲动。 背景 一些预备知识 同步阻塞 同步非阻塞 I/O多路复用 异步非阻塞I/O 其他 总结 背景既然是模型，说明为了解决一个特定的问题. 那么I/O模型是为了解决什么问题呢？首先排除网络传输问题，那么只能是网卡接受到数据之后，如何给程序消费这个问题了。程序A想要请求网络数据，程序B也要请求网络数据，以此类推，很有很多程序干类似的事情。 一个程序请求网络数据，会牵涉到四方: 程序本身 CPU 操作系统 内存 根据之前提到的”又快又好”的指标，如果这四方都能在程序请求网络数据的过程中，让自身的效率达到最有，那么I/O模型的目的就达到了是的，这也是I/O模型的终结目的. 一些预备知识用户空间和内核空间 为了保证内核数据的安全，操作系统将寻址空间分为内核空间和用户空间.可以想象一下，一家公司组织去看文艺演出，前排坐的都是领导，后排坐的都是员工，前排的区域是核心区域. 进程的阻塞 一个进程在执行的过程中，需要等待某件事情的发生，才能继续执行，那么进程有两种选择 占用CPU 不占用CPU 如果进程选择不占用CPU, 那么意味着进程被阻塞了，进入等待状态。如果进程自己等待某件事情的发生，又不释放CPU的使用权，那么这个进程是自私的。 页缓存 - Page CacheLinux内核为文件提供了一个缓存，换言之， 从网卡进来的数据，先放到内核的缓存区。接下来的事情就很自然：数据会在在某个场合下拷贝到应用程序的地址空间. 同步和异步的区别要区分同步和异步，就选取一个好的视角，这个视角就是应用程序. 现在一个程序A, 程序B, 网络请求接口getUser，这个接口执行的时间耗时不确定. 程序A 调用 getUser, 等待了t时间之后，得到了结果，然后继续执行剩下的逻辑, 这就是同步调用. 程序B 调用 getUser，继续执行剩下的逻辑，过t时间之后，以某种方式(回调函数)拿到了结果，这就是异步调用. 在这里，没有操作系统的概念，没有CPU的概念，没有内存的概念，可以看到这是一种调用方式，这种调用方式可以被框架来实现。而且可以看得出，同步调用符合开发者的认知习惯，因为代码的书写顺序就是代码的执行顺序，所以同步更人性化。默认情况下，我们写的代码就是同步的. 同步阻塞同步阻塞就是一个进程在等待某件事情发生的时候，让自己进入等待状态，让出CPU的使用权，待数据 从网卡到内核区 然后从内核区和程序地址空间再唤醒进程。在这里可以看到进程做了两件事情 干等 让出了CPU所以可以看到进程还是让自己充实点的，在等的期间可以干点别的事情。 同步阻塞的优点 实时性好.符合用户的认知模型. 同步阻塞的缺点 效率不高 同步非阻塞同步非阻塞是同步阻塞的优化，也就是进程别干等了，干点别的事情. 但程序需要每隔一段时间轮训数据有没有达到内核区域，如果达到了内核区域，就将内核区域的数据拷贝到应用程序地址空间，在这拷贝的过程中，进程是被阻塞的.所以非阻塞强调的是数据从网卡达到内核区这个过程.同步非阻塞的优点 进程不是纯粹干等了，可以去干点别的事情. 同步非阻塞的缺点 实时性差。因为需要通过轮询才能拿到数据，因为数据有可能在两次轮询间隔期间已经准备就绪了。轮询是有代价的，也需要消耗CPU I/O多路复用上面提到了同步非阻塞的缺点就是需要轮询CPU拿到结果，轮询是有代价的.有两个进程采用同步非阻塞，那么两个进程都需要轮询，如果有n个进程呢？那么n个进程都需要轮询，这种效率是低下的。 如何改进这种效率呢？一个可行的思路是让一个东西（暂且称为X）统一管理轮询。统一管理是一种哲学，比如线程池是统一管理线程，连接池是统一管理连接.Unix下面的select, poll, epoll就是做类似的事情的。 select POSIX规定的 调用select函数之前需要将文件描述符从用户态拷贝到内核态. 调用过程是: 应用程序 -&gt; select(轮询) -&gt; I/O数据，在应用程序拿到I/O数据之前，应用程序一直是被select阻塞的，就这样看来，它不比同步阻塞调用高明. 切换一个角度：如果有好多应用程序，那么这个优势就很明显，读取数据由select统一管理. 所以select的特长是处理更多的连接. poll 本质上和select是一样的，但是select的加强版 select的文件描述符列表是有限制的，而poll是没有限制的 epoll - Linux特有的, 在Linux 2.6 引入. 文件描述符放在内核的一个事件表中，这个事件表是基于红黑树的实现的. 基于事件驱动的I/O机制，只关注有I/O事情发生的文件描述符 相比与select/poll, epoll性能更高 epoll的实现是基于Reactor模式 观察select, poll和epoll, 会有这样一条线索 如何又快又好的管理文件描述符 用一种高效的数据结构 - 红黑树 避免文件描述符在用户态和内核态之间的移动 不主动去监控文件描述的变化，而是文件描述符有变化的时候，主动通知消费方 - 好莱坞原则 异步非阻塞I/O回头来看看同步非阻塞I/O的缺点 进程需要轮询才能拿到结果 数据内核区拷贝到程序地址空间的过程中程序被阻塞了 如果能避免上面那两个问题是不是就完美了？ 是的.异步I/O的宏观视角： 程序A 调用 getUser， 继续执行剩下的逻辑, t时间之后，以某种方式（通常是回调）获取结果。 其他windows IOCPlibevent libevent 是一个基于事件驱动的异步I/O库 libuv libuv也是一个基于事件驱动的异步I/O库，主要用在node.js上. 在linux上, libuv是基于epoll. 在windows上, libuv是基于IOCP Reactor 模式Reactor的英文原意是核反应堆，一个核反应堆可以提供很强的能量.Reactor是一种这样的模式，它要求主线程负责监听文件描述符是否有事件发生，有的话就将事情发送给工作线程. 所以这里可以看到几个特点: 将线程分为两大职责，一种是管理者，一种工作者 管理者负责信息的收集，然后将信息分发给工作者。从实现的角度，体现了事件驱动。从原则的角度，体现了好莱坞原则.Proactor 模式 总结同步和异步是类库，框架或者语言层面的事物，比如张三开发了一个类库对I/O多路复用进行了封装，那么我们可以说这个类库支持异步I/O.阻塞和非阻塞是操作系统进程层面的事物。Linux I/O模型的发展历程围绕了两个要素 让应用程序尽可能的多做事情 让CPU尽可能的充分利用]]></content>
      <tags>
        <tag>网络</tag>
        <tag>I/O</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之离弦之箭 - 高并发]]></title>
    <url>%2F2020%2F10%2F06%2Fconcurrent%2F</url>
    <content type="text"><![CDATA[一个系统如果足够稳定，而且客户对它也很满意，我们一般没有去优化它的必要，但如果随着用户量增加，系统变的缓慢，我们就有优化它的必要性了. 借用我前面博文《一种可以衡量事物的指标-快和好》，一个系统追求的目标之一是快，但快的前提的是好，也就是稳，否则步伐太大了就容易扯着蛋了. 优化系统是大的话题，这里只讨论其中的一个小领域-高并发.任何一个计算机的问题，都能从现实中找到雏形和模型，高并发也不例外。高并发的内容还是比较多的，所以不同类型的高并发问题需要不同的角度，就好像作战的时候，战斗机需要在高空1万米，也需要突然下降到高空1千米，也有可能是潜艇下沉到水下几千米配合作战. 这种思维模型我给它取了个名字叫“海陆空”模型. 什么是并发？ 为什么需要并发？ 如何使用并发？ 并发的身影 并发的未来？ 什么是并发？从现实的角度，并发像什么？ 在现实世界里，我们做事是有顺序的，比如做完了事情1，再做事情2, 也有可能是没有顺序的, 事情1和事情2是可以同时进行的. 所以我们在这里看到两个特征 事情是可以拆解的 从人的观察者角度，在一个时间窗口(t0-t1)内，事情是同时进行的.在这里，我没有没有提到任何程序领域的术语，换句话说，上面的这两个特征在管理学是常见的，这两个特征可以认为是并发的雏形. 从编程的角度，并发要解决的核心问题是什么？并发要解决的核心问题是 分解 - 如果要对一件事情进行并发处理，那么这件事情最起码是可以分解的, 如果这件事情不能分解，那么并发无从谈起. 协作 - 这个问题不具备必然性，仅仅发生在事情1和事件2有关系的前提下，比如事情2依赖事件1的结果 互斥 - 处理事件1和事件2的时候需要访问同一个资源，如果保证访问资源的时候只能自己访问，而且要保证系统的整体的利用率？以上三个问题可以说是层层递进的, 有了分解才有可能协作和互斥.这就是任何编程领域，并发要解决的所有问题种类吗？答案是肯定的.但有人可能很疑惑，并发不是会牵涉到什么自旋锁，可重入锁，分片还有什么volatile么？哦，不急，因为现在战斗机还在天上1万米的高空巡逻，遇到特定的问题和特定的目标慢慢会下降的.也可以想象这是一部小说，这部小说有三条主线，这三条主线最终会汇聚到一起的. 在开发者眼里，并发的目的和远景是：用一种符合开发者认知模型的方式来解决上述三个问题. 换句话说，就是认知成本少点。 为什么这件事情很重要? 我们开发软件是属于工程领域而不是科学领域，所以安全可控是首要目标，要是谁写个高并发，写的很炫，但很难维护，很难测试，最终会让人抓狂. 人是习惯的产物，就比如做西红柿炒蛋这个菜，我们知道放完鸡蛋会放西红柿，而不是黄瓜. 所以高并发的编写应该符合人的认知模型. 并发遇到的阻碍是什么？并发要解决的问题都是有实际意义的事情，看起来很美好。就好比我要成为富豪一样，这件事情本身没有错，但容易吗？不容易，因为资源有限，能力有限.并发要落地，还得需要计算机来帮忙，所以得看看计算机能不能让我很容易的达到并发这个目标，最好是我说一句话就能达到并发的目的.一个基本事实：CPU, 内存, I/O的速度不匹配. 根据木桶原理，一个系统的瓶颈取决于最短的那块木板. 姚明在休斯敦的时候，战术基本上是围绕着姚明来打造的，后来麦迪加盟火箭，管理层对麦迪的要求是球队的大战略是必须等姚明落位之后才能开始进攻，麦迪只能同意这种战略。火箭的慢的原因是在于姚明。无奈啊，黄种人跑不动。 现在基本事实已经确定了，可以说这些基本事实是原罪，是障碍的起点。可能有人要问，为什么不能把 CPU, 内存, I/O的速度弄成一样呢？这个从硬件上来说真不好弄.既然从硬件层面上解决不了这个问题，那就从设计和策略的角度上来解决. 计算机系统的参与方都开始大展拳脚.一个重要的规律： 任何的方案有好处，也有代价，这个代价可以理解为成本或者副作用，应了那句天下没有免费的午餐. 计算机体系结构的策略 - 增加 CPU 缓存，平衡CPU和内存之间的速度差异 在单核时代，只有一个CPU缓存，CPU缓存和内存之间的一致性很容易解决。一个线程更改了CPU的缓存，另外一个线程是可以知道这个CPU缓存被更改了的. 这个知道就叫做“可见性”. 在多核时代, 有多个CPU缓存，线程1操作 CPU1缓存，线程2有可能操作的是CPU2缓存。这个时候线程2就不知道线程1的操作结果了. 操作系统的策略 - 增加进程，线程，平衡 CPU和 I/O之间的速度差异 我们之所以能一边听音乐，一边发微信，是因为操作系统多进程的功劳，换句话说操作系统定义了时间片这个概念，比如在最开始的10毫秒把CPU的资源分给进程A,接下来的10毫秒把CPU的资源分给进程B, 这样能充分利用CPU资源(充分利用资源这是一种政治正确，谁会鼓励说浪费资源呢？)，给用户的感觉就是同时做两件事情. 正如去医院看病的时候，每个人都拿了一些号，叫到张三，张三就进去会诊，在会诊的时候，医生要让张三去抽血，才能得出完整的会诊结论，在张三出去抽血的时候，医生在干嘛呢？在等张三吗？显然不是. 可继续为李四会诊，等张三抽血完毕，再为张三会诊. 在这里可以看到, CPU和医生的角色有点类似. 但这样的策略会带来的一些问题，从操作的角度来说，会有任务切换这个概念. 举个例子, count = count + 1 是语言层面的代码，这个代码在CPU的角度看来是三个指令, 所谓的任务切换是CPU指令级别的切换，而不是语言层面的切换. 所以我们希望能有一个策略保证任务切换的效果是基于语言层面. 编译器的策略 - 优化指令的执行顺序 编译器会对一些代码的执行顺序进行优化, “a=6；b=7”优化之后可能变为”b=7;a=6;”, 这个代码看上去正常, 但在某些例子上却有意想不到的情况，比如双重加锁的单例模式，会引发空指针异常. 为什么需要并发？系统是要追求快，在快的基础上追求好. 如何使用并发？原则 不要并发程序 避免有共享变量 不变模式 优先使用成熟的工具类 迫不得已的时候使用低级的原语 等待通知机制优化循环等待 模式 Immutability Copy-on-Write ThreadLocal Guarded Suspension Balking Thread-Per-Message Worker Thread 两阶段终止 生产者消费者 Actor 软件事务内存 协程 CSP 方法 Java是如何解决并发路上的障碍的？ 可见性和顺序问题 final 表明这个变量是不可变的 volatile volatile int x = 0, 告诉编译器对x的读写不要用CPU缓存 在JDK1.5以前，忽略了多核的情况，在JDK1.5对volatile进行了增强. synchronized 8个Happens-Before原则 程序的顺序性规则 Volatile变量规则 传递性 管程中锁的规则 - 对一个锁的解锁 Happens-Before 于后续对这个锁的加锁 线程Start规则 线程Join规则 线程中断规则 对象终结规则 小结 可见性和顺序性问题主要由Java内存模型的规范来解决 A Happens-Before B 意味这 A做了某件事情B是知道的。 原子性问题 原子性问题是由CPU线程切换引起的，所以禁止CPU线程切换是一个很自然的思路，要禁止CPU线程切换就要禁止中断，但禁止中断这种做法只在单核CPU上有效 互斥就是要保证同一时刻只有一个线程执行 synchronized是Java对管程的一种实现 一把锁可以锁住多个资源 如何实现等待通知机制? synchronized 配合 wait()、notify()、notifyAll() Lock和Condition Semaphore ReadWriteLock StampedLock CountDownLatch和CyclicBarrier 其他 锁 一把锁可以锁住多个资源 资源和资源之间有协作关系 用不同的锁对受保护资源进行精细化管理，能够提升性能，可能的代价就是死锁。 资源和资源之间没有协作关系 多把锁不可以锁住一个资源 用锁两大要素：锁定的对象和锁定的资源. 并发的身影并发的未来]]></content>
      <tags>
        <tag>Java</tag>
        <tag>高并发</tag>
        <tag>高性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java之黑暗森林 - JVM]]></title>
    <url>%2F2020%2F09%2F30%2Fjvm%2F</url>
    <content type="text"><![CDATA[一直以来，JVM是Java开发者进阶过程必然要遇到的一块知识点。JVM离绝大多数开发者的实际工作还是比较远的，让人感觉是一个华而不实的东西。或者说有某一类群体，学习JVM就是为了面试，而且是以机械背诵的方式来学习JVM的，这都已经背离了学习一个知识的初衷. 什么是JVM JVM主要解决了哪些问题？ JVM点滴 什么是JVMJVM是一种将高级语言转位机器码的一种工具，目前支持的语言有Java, Clojure, Kotlin, Scala, Groovy.当从整体上讨论JVM的时候，有两种角度 JVM规范 JVM实现 在Java的世界里, JVM主要干了两件事（本文以下的讨论都以Java为基础） 将Java文件转为Class文件 将Class文件转为机器码 这两件事描述起来很简单，但从实践角度来说，有很多的细节和技巧，根据我前面提到过的“又快又好”的指标，JVM的目标是如何又快又好的干这两件事. JVM主要解决了哪些问题?JVM要解决Java开发过程中遇到的所有问题，比如泛型，异常，基本类型等等，根据二八法则，这里我只讨论一些大的问题，其余琐碎的问题以后单独再聊. 内存的分配这个问题是个通用的问题，可以简单的描述为：如何将有限的资源合理的分配给各种各样的消费者？或者这个问题接近于现实中的情况：如何将土地和财富分配给社会各阶层的人？所以内存分配的第一个问题，就是要搞清楚: Java里面占用内存资源的有哪几类要素？如图所示 线程共享 堆 存放new出来的对象 数组 方法区 类信息 class文件常量池 静态变量 常量信息 线程不共享 程序计数器 程序计数器是记录的字节码的地址信息。每个线程都有自己的程序计数器，当线程的CPU时间片耗尽挂起之后，需要记录字节码的执行位置，当再次获取到时间片之后，可以从上次的位置继续执行。这个功能是必要的，好比我们看完书的一段章节之后，会将这一页折一下或者用笔做个标注. 执行Native方法的时候，程序计数器没有值，因为本地方法不是基于字节码来实现的. 虚拟机栈 符合栈的特性：先进后出 栈帧 - 方法级别的概念，简单来说，方法执行之前栈帧入栈，方法执行完毕，栈帧出栈。 栈顶的元素通常称为当前栈帧，里面与之相关的方法称之为当前方法. 本地方法栈 - 和虚拟机栈大体类似，但处理的对象不同，本地方法栈处理的是本地方法 没有栈帧的概念 内存的回收一个消费者资源使用完了，就需要回收，以便给其他消费者使用。 锁 类文件是如何加载的 JVM 点滴]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尘埃落定-k8s]]></title>
    <url>%2F2020%2F09%2F24%2Fk8s%2F</url>
    <content type="text"><![CDATA[K8s已经成为了容器编排的事实标准。k8s一路走来也有些曲折，但最终笑傲群雄。它这一路走来发生了哪些恩怨情仇呢？ 背景 什么是k8s? 为什么是它？ k8s底层是如何实现的？ k8s生态及相关 背景 想起多年前在上家公司，如果要发布一个功能，得是运维人员先停止服务，然后手动拷贝文件到服务器上，再启动服务，这个过程是纯手工操作，在那时看起来也很自然。在那个时候流行的是在aws或者Openstack上租一台虚拟机，然后通过手动或者脚本的方式来部署程序，这里会遇到一些问题，比如云上的环境和本地环境的不一致，所以云服务厂商比拼的就是谁的环境更能模拟本地环境。 Cloud Foundry 随着Cloud Foundry的出现，部署的方式稍微有点变化，对于用户来说，只需要将程序打包成它规定的格式，上传上去就好了，Cloud Foundry会调度一个虚拟机来执行这个程序。这个时候会遇到一种情况，如果这个虚拟机执行很多程序会不会导致程序之间会有冲突？不会，Cloud Foundry会为每个应用创建隔离环境. 这一切听起来不错. Docker 再后来Docker出现了，现在我们知道，Docker也是为应用创建隔离环境，看上去Docker不必Cloud Foundry高明多少啊。但Docker杀手锏是镜像，镜像意味着无论什么应用都遵循统一的格式和规范, 更关键的是镜像包含了应用所有的依赖，而Cloud Foundry则需要为不同的应用生产不同格式的包，比较繁琐. 在这个时候, Cloud Foundry并没有拥抱Docker作为自己打包的标准，失去了一次战略先机. Docker虽然可以提供标准格式的包，但它没有部署复杂应用的能力，因为Docker本质还是一个工具.于是在2014年底, Docker公司推出了自己的容器集群管理工具Swarm，打造一套以容器为核心的Paas, 并形成Docker自己的生态. Mesos Docker此时有个竞争对手叫Mesos, Mesos有个独特的杀手锏就是超大规模的集群管理能力，有超过10000个节点成功案例，而且支持Docker容器部署。 现在看起来，两强相争似乎成了基本盘。 Kubernetes 但在2014年出现了一个叫Kubernetes的东西. Google, RedHat等基础设施大佬们成立一个名为CNCF的基金会，专门来对抗以Docker为核心的生态的。 所以现在是生态和生态之间的对抗，而不是工具和工具之间的小打小闹。那么K8s是如何破局的呢？ k8s面临的困境 对于Docker生态来说， Swarm和它的配合可以说是如丝滑般的顺畅 对于Mesos来说，它的特长是大规模集群调度. k8s的突围之道 很明显，如果模仿Docker或者Mesos，任意一条路都是走不通的. 那么k8s只有两个方向了 融合Docker和Mesos的优点 单独开创一个局面K8s选择的是单独开创一个局面：容器编排，并且要在这个领域取得压倒性的优势，并形成降维打击. 什么是k8s? k8s是什么？正如背景里面所描述的，k8s是一个容器编排的工具. 所以 它本质是个工具 它处理的实体的是容器，这个容器不一定是Docker,说不定将来出来了一个Eocker. 它的重心是编排，有点类似于NBA里面教练对球员的排兵布阵.它提供了一种通用的方式来定义任务之间的关系，并为未来可能存在的新的任务关系提供可扩展性。直白一点，这个世界上所有的任务关系都应该在k8s的掌握之中. 从抽象的角度来说，一个集合里面由很多元素，编排意味着，要将这些集合分组，可以定义组和组之间的关系，可以定义组内元素之间的关系，可以定义跨组元素之间的关系。 从实践的角度来看，编排意味着 如果一个服务的访问量过大，如何扩展服务的实例 如何限流 如何保证服务只被合法的用户访问 如何合理分配流量到不同的服务实例 如何知道服务之间的调用链 如何实现服务之间的启动顺序？ 切入k8s的一种角度从宏观的角度来看，K8s有两种角色 Master节点 - k8s的大脑，类似于球队的管理层和决策层. kube-apiserver kube-scheduler kube-controller-manager Node节点 - k8s任务的执行者。 kubelet组件， 它可以 通过CRI同容器运行时打交道，CRI请求会被转换成Linux系统调用 和设备插件打交道，比如GPU 和网络插件和存储插件打交道不管是Master节点还是Node节点，它们运行的载体是物理机或者虚拟机，为了方便理解，可以认为一个节点对应一台物理机. k8s的核心概念 Pod - 对于K8s来说, Pod是最小的执行单元,是对容器的抽象和封装.正如研究动植物一样，细胞是最小的单元。一个最小的Pod就是只包含一个容器镜像。也可以认为Pod是k8s的一等公民 必要性 - 有些应用之间需要通过本地文件交互信息，或者交互很频繁，需要通过LocalHost来通信。在正常情况下，这些应用（进程或者进程组）会被部署在同一台机器上. 容器本身没有管理多个进程的能力， 回到k8s身上, k8s也需要解决这些问题，所以Pod这个概念应运而生，最复杂的Pod应该是很多应用在一起, 所以Pod可以看作是一个逻辑实体. 临时性 - Pod的地址是临时的，但在相应的的物理机或者虚拟上的网卡可以找到这个地址. Deployment - 一个应用看作是一个实例，那么Deployment可以让Pod有多个实例. Deployment和Pod从设计的角度是一种API对象，Depoyment用来管理Pod。一种API对象来管理另外一种API对象，在K8s里称之为控制器模式. Deployment是让Pod活跃起来的一个API对象，其他对象没有这个功能. Deployment隐含里水平扩展和收缩的功能. 正常Deployment的定义包含两部分 Pod副本的数量 - spec.replicas Pod的描述 - spec.template 对于一些特殊的应用比如Sticky Session, 需要自定义Deployment ReplicaSet - Deployment是通过ReplicaSet来控制Pod的. ReplicaSet定义了Pod的数量 Deployment控制了ReplicaSet的个数 Service - 由于Pod每次启动之后，IP地址都会变化，这样就导致了Pod之间相互通信很困难，必须有一个东西来解决这个问题，Service这个概念应用而生，它代表的是稳定的地址和端口. 一个Service可以对应多个Pod,所以Service需要有负载均衡的能力. Ingress - Service在默认情况下，只能在k8s集群内被访问，如果想要让外网可以访问service,就需要做有些额外的事情, Ingress就是干这个的. Secret - PodA 访问 PodB 需要带上用户名和密码，那么这些用户名和密码就放在Secret对象里，这个对象本质上ETCD里的一条记录. 为什么是它？K8s能成为容器编排领域的事实标准，与它的正确的战略定位分不开，也与它本身自带“贵族气质”有关.K8s每一个核心特性的推出，都来自于Borg/Omega系统的设计和经验, 可以说是站在巨人肩膀上, 而且这些特性借助于开源社区的力量，变得越来越好. k8s底层是如何实现的？k8s生态及相关]]></content>
      <categories>
        <category>基础设施</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>PaaS</tag>
        <tag>基础设施</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker初回忆]]></title>
    <url>%2F2020%2F09%2F21%2Fdocker%2F</url>
    <content type="text"><![CDATA[从第一次接触Docker到现在大概也有两年多了, 基本上停留在用的层面.现在是时候回顾一下这项革命式的技术了. 什么是Docker? 为什么是Docker? Docker是如何实现的？ Docker的实践 Docker的未来 什么是Docker?Docker是一种虚拟化技术，可以实现资源的隔离.在我和朋友的交流中，我对Docker官方Logo挑过刺， 原因是 docker的英文原含义是码头工人, Docker的logo没体现这一角色 这个logo上面的的集装箱代表的是一种隔离，但不能表面这是Docker，虚拟机也能隔离，也可以是集装箱啊. 历史Docker的前身是Linux容器(LXC), 但LXC本身比较复杂，不易于管理和使用。 核心概念Docker有三大核心概念 Image - 可以理解为一个文件，这个文件包含了程序，和相应的环境. 一个镜像可以代表特定的目的。比如最简单的镜像就是copy文件 镜像是分层次的。分层的好处就是镜像可以被复用。 Container - 镜像运行起来可以看作是容器。 有自己的root文件系统 有自己的网络配置 有自己的进程空间 从操作系统的角度来看， 每个容器都是docker daemon的子进程。 从容器的行为来看，对于运行在容器内的进程来说，容器就是像是操作系统。 有句俗话，如果一个动物走起来像鸭子，叫起来像鸭子，游泳起来也像鸭子，那么它就是鸭子 Repository - 专门用来存放镜像的地方, 所以要获得一个镜像需要知道三种类型的信息 仓库名 镜像名 镜像的版本 为什么是Docker?Docker和虚拟机的区别虚拟机和Docker一样可以做到资源隔离，那为什么是Docker笑到最后呢？虚拟机模拟的是硬件，在模拟的硬件基础上，安装操作系统，运行程序。Docker没有模拟硬件，直接依赖于宿主的内核. 启动速度。Docker启动速度约等于本地进程，虚拟机起码要10几秒以上. 占用资源。假设一个进程是10M, 如果用虚拟机启动，占用的内存资源起码好几百兆，因为虚拟机是整个操作系统的模拟。如果用Docker, 相当于在进程外面包了一个壳,充其量占用的是几十兆的资源. 虚拟机的优点是能提供完整的操作系统内核，但Docker没有内核，可以认为Docker没有魂，采用了某些技巧让使用者看起来像虚拟机. 根据10倍好理论，一个事物要代替另外一个事物，仅仅是好一点是不够的，要好就要10倍以上. Docker的实际应用 构建微服务 让开发和运维之间职责分离和明确，不会打架. 保证各地方环境的一致性 不会出现那种在本地程序是好的，怎么到了开发环境就报错这种情况. 一般来说，程序员只关心代码和本地开发环境，至于怎么上QA, Staging, Live，这些事情不是程序员关心的。 Docker是如何实现的？Docker隔离资源原理 Namespaces - 让进程看来拥有自己的资源。有以下6种隔离 主机名和域名 进程间通信 进程号 网络 文件系统 用户管理 CGroups - Linux Control Group. 光隔离还没有用，因为进程还是可以无限制访问宿主加上的资源 限制内存 限制CPU 限制磁盘 限制网络 局限性 /proc目录下的文件记录的是宿主机的内核运行的信息，会造成内核信息的泄露。 rootfs 包含了一个操作系统的文件,配置和目录，但不包含内核，内核用的还是宿主机的。 rootfs让环境的一致性是成为了可能. Windows上的Docker和Mac上的Docker因为没有Linux内核，只能基于虚拟化技术来完成. 所以一开始在windows接触Docker的时候，不知道为什么要安装一个虚拟机. 一些事实 无论怎么隔离，这些进程是共享宿主机的内核。所以在windows宿主机上运行linux容器，或者在低版本的linux宿主机上运行高版本的linux容器是行不通的 Docker容器内修改时间，目前来看不会导致宿主机Mac的时间被修改. 所以一个容器就等于宿主机上启动了一个进程 这个进程启用了多个Namespace 受 CGroup控制 限制这个理念也正是我之前提到的系统的约束，戴着脚镣跳舞才能守规矩. Docker的实践Docker常用命令 构建镜像 - 前提是有Dockerfile存在docker build -t ricky:0.0.1 . 查看镜像docker image list 或 docker images 启动镜像docker run -t -i ricky:0.0.1 /bin/bash 查看Container运行中的容器 docker ps 或 docker container ls 所有容器 docker ps -a 或 docker container ls -a Docker的未来Docker的启动速度接近于本地进程了，所以在启动速度这块未来不可能有大的进展了.Docker需要做的是规范公用镜像，让公用镜像更小，更安全。Docker如果运行在物理机，如何保证Docker内部的东西不暴露给外界，且不侵害到物理机呢？Docker需要强大它的生态圈]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务架构二三事]]></title>
    <url>%2F2020%2F09%2F20%2Fmircro-services-archi%2F</url>
    <content type="text"><![CDATA[就现阶段而言，DDD已经成为微服务设计的事实标准，也不排除未来可能是有更好的微服务设计标准。这篇文章聚焦于传统的架构应该如何过渡到微服务架构。 传统三层架构 传统的DDD分层架构 依赖倒置的DDD分层架构 DDD 五层架构 DDD 六层架构 六边形架构 整洁架构-洋葱模型 传统的三层架构人往往会忽视简单和习以为常的东西，就比如“好好学习”这句话。三层架构是所有架构的基石和鼻祖，当若干年之后人们再会想架构的时候，首先想到的应该是三层架构。我们应当向三层架构致敬.正如我前面的提到的《分解》，软件开发的核心原则是分解。今天是这个分解，明天是那个分解，分解和分解之间的不同是维度的不同 根据奥卡姆剃刀原则，如果一个问题有两个模型可以解释，那么肯定选择最简单的那个模型。想到霍金提到的一个例子 两者都是正确的宇宙模型，人们既可以假定地球静止，也可以假定太阳静止来解释星球的运转，只是哥白尼的日心说具有比较简洁的优势，可以用简单的运动方程来解释太阳系行星的运转。因为用地心说来描述星球的运行将非常复杂，不但要考虑天体的旋转，还要考虑地球的自转，因此托勒密虽然制作了以地球为中心的模型，很多现象依然无法解释，不得不用偏心圆和小轮体系来进行修正. 简而言之，地心说本身没有问题，只是在解释宇宙的时候更复杂，不如日心说那么简单. 这个道理通用适用于三层架构模型。 三层架构不考虑实现，仅仅从概念上来说是完美的。 数据库 - 代表了信息存储的地方，也代表了事实，可以作为企业决策的依据。 数据访问层 - 这一层主要用来获取数据库信息。 业务逻辑层 - 世界上一切行为都可以看作是业务逻辑，这一层主要是加工（分解和组合）信息。 用户界面层 - 用来显示给用户显示信息。 三层模型从概念上是抽象度极高的，抽象度高意味着在落地时候还需要做很多工作. 基本上，在三层模型里，对任意一层，可以有如下处理 将这一层根据需要拆解成n层 将这一层和其他层合并 这一层和其他层之间增加新的一层 我个人很感兴趣的一件事情： 三层架构模型能不能像魔方一样经过几次变换然后变成其他架构模型呢？ 传统的DDD分层架构 从概念上来说, 传统的DDD4层模型可以由三层模型稍加改进得来. 用户接口层， 这层对应三层当中的用户界面层. 可以有两者解读 广义上是指UI，API 狭义上是指API 应用层，组合领域层和调用其他应用层。 这层可以看成是由业务逻辑层拆解而来。 领域层，这是整个系统的重点，也是兵家必争之地。领域层要确保在整个系统的复用性.这层可以看成是由业务逻辑层拆解而来。这层包括 领域服务的定义 领域对象的定义 领域事件的发布 基础设施层，包括缓存，队列，网关，数据库，可以对应三层的数据层. 这里的特点是任何一层都可以访问基础设施层。 就好像一个组织里，大领导可以过问下层的工作细节，下层可以越级汇报给上层。 依赖倒置的DDD分层架构 相比于传统的DDD的分层，依赖倒置的分层一点点反直觉。 传统的DDD分层，层和层之间的箭头流向代表着 调用关系-RPC调用或者发布一个事件 但是依赖倒置的DDD分层的箭头带来的确实含义完全不一样的理解 绿色的箭头代表的不是调用关系，因为很明显技术设施层怎么可能调用用户接口层呢？这是最明显反直觉的一点。所以这里(A-&gt;B)的绿色箭头代表着，B比A要重要，A的任何改动不会影响B,B的变化会影响A. 黑色的箭头代表着正常的调用。 这幅图最大的问题在于一个箭头有两种完全不同的语义. 绿色思考帽想象一个人在飞机上，有四个包裹分别为用户接口层，应用层，领域层，基础设施层，这个四个包裹的重量一样，但价值不一样。现在飞机动力不足了，我们要扔掉包裹，才能让飞机有动力继续飞行. 我们会怎么扔？ 扔第一个包裹。扔掉基础设施层，因为落地之后，换一个基础设施层就好了 扔第二个包裹。扔掉用户接口层，相比于其他层，用户接口层没那么重要. 扔第三个包裹。扔掉应用层，相比于领域层，应用层没那么重要. 所以我们可以看到领域层是最重要，只要领域层在，一个业务的灵魂就在。正如我们听到的紧紧围绕在XX同志为代表的领导下，开发业务的时候同样如此，要紧密团结在领域层周围做事情. DDD 五层架构 背景 一个人在公司里是员工，可以完成上级的任务，在家里就是父亲，可以教育子女. 如何用从代码层面描述这两种场景，而且符合开发者的心智模型？ 张三 + 场景 (公司) -&gt; 完成上级任务 张三 + 场景（家里）-&gt; 教育子女 一个可行的的公式：谁(Who)什么时候(When)在什么地方(where)用什么方式(How)完成了某件事(What)？基本上这个公式可以描述很多场景的行为，这样能保证描述不具备歧义性。比如：我上午骑车去超市买了瓶可乐。 什么是五层架构？五层架构也叫DCI(Data + Context + Interactive)架构，是2009年由James O. Coplien和Trygve Reenskaug共同提出.DDD五层是对DDD四层的改进 Context层 - 由四层的domain拆解而来 负责将领域对象变成Role Domain层 - 由四层的domain拆解而来 object - 描述对象的关系 role - 用来给对象创建一个 role, 员工或父亲。 这个Role可能以后会带来歧义，因为一些权限验证框架里面也由Role这个概念. 什么时候应该用五层架构？ 梳理完整个业务之后，如果一个实体在业务中有多个不同的称呼，这个时候就应当用五层架构模型，如果实体在业务中的称呼是唯一的，那们就四层模型就够了。可能有朋友要问了，如果用四层模型，现在业务实体的称呼只有一个，那将来实体要是有多个称呼可怎么办呢？那就演化到五层。 DDD 六层架构六边形架构 整洁架构-洋葱模型]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统的约束和动力]]></title>
    <url>%2F2020%2F09%2F18%2Fsystem-restrain-power%2F</url>
    <content type="text"><![CDATA[一个系统能发展是有动力，如果要让系统发展的好则需要约束。就好像汽车的前进是靠发动机，汽车的减速靠的是刹车，汽车行进的方向靠的是方向盘。发动机是动力，刹车和方向盘是约束.那么动力和约束与生活有什么关系呢？ 让我们从直觉和感性的角度来一场探索之旅吧 系统的动力 系统的约束 约束和动力之间的关系 系统的动力一个系统的动力在不同的情况下可以有如下的表现形式 人类的各种欲望，比如挣钱，获得胜利，获取别人尊重 一辆汽车的引擎 一个公司想盈利 动物生存和繁殖的本性，尽可能得获取更多的资源。 产品需求的不断变更 像系统的正反馈，是一个熵增的过程 一个人成长的力量，比如体能,目标，价值观 系统的约束一个系统的约束可以体现在如下方面 有限的客观物质。比如一个吃糖里的水是有限的。 规则。人制定的法律制定 道德。一个组织内自发形成的非强制性约束 代码规范。长期以来形成的最佳实践。 项目的发布流程。 一辆汽车的刹车和方向盘 像系统的负反馈，是一个熵减的过程 阻碍一个人成长的要素，比如懒惰，恐惧，急躁，贪心, 骄傲, 自我认知失调 等等. 规范一个人的成长要素，比如自律，计划. 所以约束有如下含义 有限的资源。 只做什么，暗含着只在边界内做事 不做什么，暗含着不要在边界外做事。 约束和动力之间的关系没有约束，系统就要失去控制。没有动力，系统就不会发展。约束是保证系统更快更好的发展，达到一种平衡的状态。一个人如果没有约束，最终会越来越堕落。一个组织如果没有约束，最终会人心向背，分崩离析。一个国家如果没有约束，最终会陷入混乱状态。 一个小孩在成长的过程中，需要家长和老师的教育，才能成为一个有健全人格的人。一个项目从立项到完成，再到维护，如果没有建立一个很好的流程规范，项目的会变得很难维护。如果一个项目存在了10年左右的时间，那么肯定有好多人修改过，每个人都有自己的风格，如果修改代码的时候不遵循一定的规范，项目最终会变成脆弱的系统。]]></content>
      <categories>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮浮沉沉 - DDD]]></title>
    <url>%2F2020%2F09%2F15%2FDDD%2F</url>
    <content type="text"><![CDATA[现在谈到微服务，大多会提到DDD, 这两者之间有什么关系呢？让我在这篇文章里揭秘吧. DDD是什么？ DDD设计的一些原则? 如何基于DDD实现一个服务? DDD的反面是什么？ DDD 是什么？ DDD(Domain Driven Design)是一种设计方法论，它提供了一种拆解知识和问题的方式. DDD的背景 2004年Eric Evans 出版了《领域驱动设计》。微服务发迹于2014年。但这10年间DDD可以说是默默无闻，就好像一个妃子被打入冷宫一样，直到微服务出现，两者才喜结良缘，很难说谁成就了谁，两者是如此的契合. DDD的核心概念 DDD有将近10个左右的概念。这些概念都是为了搞清楚一件事：业务的边界是什么？什么样的东西应该放在这个业务里？什么样的东西不应该放在这个业务里？ 人世间的争论大多数是名词之争。以前看《李敖有话说》，李敖提到了这样一个故事 我想起《展望》（The Outlook）总编辑艾勃特（Lyman Abbott）自传中记他父亲的谈话：“自古以来，凡在哲学上和神学上的争论，十分之九都是名词之争。”艾勃特接着说：“我父亲的话是对的。但我年纪愈大，愈感到他老人家的算术还有点儿小错。——剩下的那十分之一，其实也是名词之争。” 一个人叫张三，无论它到世界任何角落，他还是张三，这是“实”。在公司里，张三是员工。在家里张三是父亲，父亲和员工是“形”； 一瓶酒在仓库里叫库存，在运输的过程中叫货物。 知识也是类似的。知识可以有不同的分类，可以按照规模大小来分，也可以按照重点和非重点分(二八法则)，所以大概有四种类型: 总的知识 细分的知识 重点知识 非重点知识。 但不管是哪种知识，都属于知识，具有知识的共性：知识表达了一系列的事实，行为，最核心的组成成分是名词和动词。所以一系列的的名词和动词构成了一个完整的知识. 领域 - 总的知识 子域 - 细分的知识 核心域 - 重点知识 支撑域 - 非重点知识 通用域 - 非重点知识 聚合 - 一系列名词和动词的集合。 聚合根 - 一系列名词和动词的集合，就像一个组织一样，得有一个老大负责对内对外的沟通. 实体 - 名词 + 动词，是一种充血模型，以DO的的形式存在. 值对象 - 名词 DDD设计的一些原则? 应用层实现跨聚合的调用。 聚合之间的逻辑满足最终一致性。 领域层实现跨实体的调用 聚合内的逻辑满足强一致性 要访问聚合，先找到聚合根 如何基于DDD实现一个服务?形成DDD的过程* 收集信息 * 项目负责人收集尽可能多的信息 * 召集大家一起开会，分析一个领域内有多少User case * 形成领域模型 * 对所有的User case进行名词提取，汇总出有多少核心名词 * 提取这些名词的核心行为 * 实现 * 基于上面的名词设计实体和值对象一个简单的DDD例子DDD的反面是什么？]]></content>
      <categories>
        <category>软件设计方法</category>
      </categories>
      <tags>
        <tag>软件设计方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闻香识微服务]]></title>
    <url>%2F2020%2F09%2F14%2Fmicro-services%2F</url>
    <content type="text"><![CDATA[微服务已经成为了后端开发的主流，也成为了后端初次见面打招呼的内容.微服务三个字从这字面上可以理解，但它的内涵确实是各人有各人的理解，因为微服务本身并没有被严格的定义.噢，不， 它有被定义，只是在不同的时间段被不同的权威的人定义了，据可查的资料，大概有4位专家前后给出了不同的定义，所以大家都不知道真正的定义是什么了， 也不知道未来微服务的定义会变成什么样. 因为它没有像数学公式被严格的定义。 这篇文章不试图搞清楚微服务的确切含义是什么，因为这这样做是徒劳无功的。本文试图探索 微服务大概是什么？ 为什么是微服务？ 要实现一个微服务，它应该具备哪些行为和特征？ 微服务的未来 微服务带来的副作用 微服务大概是什么？名不正，则言不顺，言不顺，则事不成。一个事物的准确定义是讨论这个事物的前提以及是后续对这个事物采取行动的基础. 正如上面所说，微服务没有被严格的定义。所以这里不能采取学院派的手法来讨论微服务。 现在假设有个用户服务，这个用户服务支持：添加，删除，修改和查询用户。用户的信息包括姓名，电话，性别，职位，地址等等.那这个用户服务是不是微服务， 至少现在它看来是微服务。但这还不够，它还需要支持 从实现的角度来看，代码在物理上是隔离的. 如果代码不是物理上隔离的，这就会导致用户服务，地址服务，订单服务在同一个 jar文件里，这样服务就不能扩展了。 所以代码必须是物理上隔离的，这才有动态扩展的可能行。动态扩展了多个实例之后，也就有了容错性。 从设计上来说，微服务职责是有边界的。如果想从用户服务获取用户的工作单位呢？不好意思，没有，请去地址服务里拿。怎么确定这个边界呢？这是另外一个大的话题. 上面这两点是我认为微服务必须具备的。这两点其实隐含了一些前提和衍生了一些必然的结论. 比如，代码库是隔离的，意味着用Java语言写的微服务可以被用Js写的微服务替代. 如果一个服务职责边界清晰且足够小的话，那们意味着这个服务是可以被组合的。 应该不会有比用户服务更简单的服务， 但不是说所有微服务都应该像用户服务这么简单。 一家饭店有一个厨房，两个服务员.厨师的主要职责是：烧菜。服务员的主要职责：切菜，上菜，收拾桌子。如果以后客流量激增，那么可以再招一个厨师和三个服务员, 很显然如果上面的职责集中到一个人身上，是无法做到细力度的控制的.这里有个问题，切菜应该服务员负责还是厨师负责？没有标准答案，这个需要领域专家从统计学上给出建议. 这也大概是软件设计的魅力吧 为什么是微服务？因为微服务的本质就是拆分一个系统，系统拆解的越小，这一小部分就更容易被理解和控制。 分解的具体讨论可参考博文《分解》 要实现一个微服务，它应该具备哪些行为和特征？理想的情况应该是： 弹性扩展量变引起质变。 当用户的数量上升到一定的规模之后，只需要增加相应的机器实例就可以解决问题，这是最理想的解决方案。 如何让一个服务可以有多个一模一样的实例? - docker或者虚拟机 请求一个服务的时候，如何选择某一个服务实例？- 负载均衡 不同的请求如何对应到不同的服务实例？ - 路由 一些服务会有各种各样不同的参数，比如JVM参数，数据库连接字符串，如何管理这些参数？- 配置中心 这些服务的网络地址是动态变化的，如何管理动态变化的网络地址？ - 服务注册中心. 一个用户进来，哪些服务他可以访问，哪些服务他不可以访问 - 鉴权 用户的请求很多，如何限制用户的请求？ - 限流 如果一个服务因为某种原因不可用了，即使增加实例也没用，那么就应当让请求不要继续这个服务了 - 熔断 服务A调用服务B，然后调用服务C， 如何知道这个调用链？ - 监控 业务演化业务的改变大体有两个 维护现有系统 开发新的功能 但无论是维护现有还是开发新的功能，我们不希望看到下面场景 开发一个新的功能很难，不知道怎么和现有系统集成。 维护一个功能很难， 就好像拆炸弹一样，生怕碰到不该碰的东西，一碰就爆炸，就是这个系统太脆弱了。 微服务的未来 从分解的角度来说，基本上不可能拆的更小了，再拆连裤子都拆没了。上面提到的用户服务可以算是最小的微服务. 从规范的角度来说，对鉴权，限流，网关，负载均衡,配置中心等等形成一个标准。每个实现都遵循相同标准的时候，可以有效地降低开发者的认知成本，符合开发者的心智模型. 正例：Java对依赖注入有JSR330的规范，这样不同的依赖注入框架可以遵守相同的标准 反例：JS模块化方案AMD和CMD. 一切可以自动化都应该自动化或者必将自动化。当然，这个结论不仅仅适用于微服务。 更好的性能. 比如性能更高的传输协议。 微服务带来的副作用当大家沉浸在微服务真香的状态中，不要忘记微服务是有代价的. 网络之间的通信。比如服务A调用服务B的时延是50ms, 如果调用链是A, B, C, D，那么这个时延就更长了，只要有网络之间通信，就存在不确定性. 当微服务数量很多，且有不同团队维护的时候，这个沟通成本和维护成本是非线性的. 需要一个掌握全貌的人，如果不能掌握业务全貌，出了问题都不知道根源在哪里. 根据鸡蛋不能放在一个篮子的原则，掌握全貌的人最好多于一个. 相比于传统MVC开发团队，微服务对开发者的要求要高些.]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux设计及相关]]></title>
    <url>%2F2020%2F09%2F14%2Fredux-design%2F</url>
    <content type="text"><![CDATA[基本上，一说到react, 正常会有一个词随之而出现，那就是Redux. 它们是一对好基友。这篇文章主要是聊聊下面一些话题 什么是Redux? 为什么是Redux? React和Redux的关系是什么？ Redux的未来 什么是Redux?Redux是一个存储数据的地方，这个地方你可以叫它为Store,或者JS对象，或者前端数据库，这些都是名，实际的内涵是存储数据.既然是存储数据的地方， 那么接下来有几个问题就很自然了 数据有哪些实体？ 数据的实体有哪些行为？ 增，删，改，查。 有哪些方式能获得这些数据？ 如何避免不同的实体有相同的冗余数据？ 对于以上问题，相信部分人可能会不耐烦了，不就是前端展示么？怎么会牵扯这么多东西.这是因为现在的前端开发有一些不需要讨论的大前提：单页.为什么需要单页呢？-给用户丝滑般的体验啊.大概的关系如下：单页 -&gt; 需要状态 -&gt; 需要存储状态的地方 -&gt; 维护状态 Redux的核心概念是什么？ store action reducer Redux的核心原则是什么？ 单一数据源 数据是只读的 单向数据流 为什么是Redux?因为需要状态管理。可以有如下三个选项 Flux Redux Mbox Redux是Flux的升级版，Mbox生态圈相对小一些。 所以一般情况下会选择Reduxs React和Redux的关系是什么？前面提到了, React和Redux还是一对好基友。但React是否需要Redux？在下列情况下，是不需要Redux的 项目比较简单，所有的状态保存在React组件里 每次请求的数据直接从后台api拿, api的性能很高，没有延迟 用户不需要好的的UI体验 但仔细审核这三点，在大多数情况下，是不成立的.所以在大多数情况，我们需要状态管理. Redux的未来?Redux的方向大概有两个 如何更好的规范数据实体之间的关系 如何提供api更好的操作数据]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React设计思路]]></title>
    <url>%2F2020%2F09%2F13%2Freact-design%2F</url>
    <content type="text"><![CDATA[React作为前端主流的UI库，逐渐占据了前端的大半壁江山。所以哪个前端如果不知道React， 那基本上可以算是大大的落伍了.在这里，主要聊聊 什么是React? 为什么是React? React是如何实现的？ React的未来 什么是React? React是一个UI库，所以 React的核心定位和使命是解决UI的问题. 传统意义上操作UI的做法是: 触发一个行为 以某种方式获取DOM 以某种方式更新DOM React的做法: 触发一个行为 更新数据 React相对于传统的UI库有几个明显的不同 抹去DOM的概念(除了一些特殊的场合需要操作原生的DOM). 这会带来额外的收益 如果没有DOM的话，那是不是一套逻辑可以应用在桌面端，移动端？答案是肯定的. 最近几年加入前端界的朋友是不需要学习DOM的，这样学习成本就低了些. 开发者只需要关注数据和UI之间的关系, UI=render(data). 具体一点, 关注 数据如何存取？ 拿到数据之后，如何构建一个好的数据模型为UI服务？ 操作数据 为什么是React? React能得到快速的发展，离不开下面几个因素： 大厂的加持。这年头背后得有个有钱的爸爸才能发展的好啊。 繁荣的生态。单纯的React解决不了大问题。 还需要配上Redux, redux-router一系列相关的类库和框架. 比较好的设计理念， UI=render(data). 相比于之前的库和框架，这个设计理念是React独有的 React是如何实现的？ 这里不打算讨论非常细的东西，比如组件的生命周期，如何更新组件的状态等等。 从宏观角度来看，在React实现上有两个绕不过去的概念 JSX class HelloMessage extends React.Component { render() { return ( &lt;div&gt; Hello {this.props.name} &lt;/div&gt; ); } }看return里面的内容，是不是很熟悉？不就是模板么？对，如果非要说成模版也没错。 但在React这里可不可能这么叫，咱得换个说法，不然怎么显示出React和别人不一样呢？从语法层面，这个叫JSX.从抽象的角度来说，这个叫组件.从实现的角度来说这个叫Virtual DOM传通的UI设计是要分离CSS, Html和JS的， 这种分类的维度是基于技术层面的划分. JSX认为一段CSS, 一段Html, 一段JS组合在一起才算是一个完整意义上的实体，是可以单独交付出去的。所以这里带来了前端思维方式的变化。 Diff算法上面说过，React对开发者是抹去了Dom的概念，但Web的展示还是基于Dom的，所以要将Virual DOM转为 真实DOM。 如何以一种更快更好的方式将Virtual DOM转为真实 DOM呢? 以后有时间单独讨论. React的未来 React的设计理念, UI=render(data)在未来很长一段时间内很会稳定. React和Vue的生态之间的竞争是一个看点. React的许可协议将来会不会有变数？]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分解]]></title>
    <url>%2F2020%2F09%2F12%2Fbreak-down%2F</url>
    <content type="text"><![CDATA[分解是解决问题的一种有效方式之一。分解这两个字是如此的显而易见，小学生一听都知道分解是什么意思， 以至于不需要解释太多。这篇文章主要探讨三方面内容 什么是分解？ 为什么要分解？ 如何分解一个系统？ 什么是分解？ 将一个事物按层次拆成层次1， 层次2，每个层次可以拆成要素1， 要素2，这就是分解。 一些具体的例子 公司的组织架构。老板下面有很多经理， 经理下面有很多项目组长. 公司的目标。 长期目标(愿景)，中期目标，短期目标. 社会大分工 软件架构的分层。 微服务的拆分。 分布式 算法分而治之的设计思想 分子可以拆分成原子，原子可以拆分为质子和电子。 经济研究可以分为宏观和微观。 新产业可以分解为现有产业和新技术的组合。 简而言之， 分解是无处不在。 为什么要分解？ 一个系统被分解之后， 它是： 容易理解的 容易解决的 一些具体的例子 一个很复杂的任务，被分解为任务1, 任务2。。。，每一项任务只需要简单执行就能得到预期结果，以至于简单到不可能失败。这个例子很简单的，简单的会让人感觉“不过如此，这个没什么啊”。任务分解是职场里最有效的工作方式之一。 它的表现形式是如此的简单，以致于人们意识不到这种方法论的重要性。去观察一个团队的领导或者成员有没有搞清楚任务，一个重要的指标就是这个任务有没有拆解得很清楚。 换句话说，能不能将任务拆解得很清楚是团队成熟和稳定的标志之一. 为什么这么说？ 想明白 - 做事的前提就是想明白，搞清楚为什么。 如果一个任务能拆解的很细，说明这件任务是想明白了。 可执行 - 可执行意味着能不能落地。人是天生讨论复杂和不确定的东西，任务分解的结果就是简单和确定的东西。 简单和确定意味着风险可控，结果可预期, 在规定时间内可以拿到结果。结果本质上是一种反馈和奖励机制，长期的反馈和奖励机制会形成良性循环. 并不是所有的系统都是可以拆解的，有些系统是非线性的，不遵守还原论. 如何分解一个系统？ 识别系统的要素 不同的层次 一个组织有领导层和执行层，领导层决定了执行层。 一个软件有一个根本设计目标和设计原则，模式和方法。 我们知道人的生命是基于碳基的，但是我们要是收集一拖拉机碳基物质，能不能创造出人类，当然是不能。碳基物质 -&gt; 细胞 -&gt; 器官，这是一个比较简单的描述人的物质组成图，很明显，每一层都不是下一层简单的堆砌就可以形成的，而是量变引起了质变，这种现象就称为层展现象. 同一层次的不同维度 如何证明美国比中国比美国强？可以从政治，经济，军事，文化，教育。。等角度出发， 这些维度是平等的。 识别要素之间的关系 比如在一个学校里，教师是管理学生的，而不是学生管理老师，如果是这样的话，那么系统的性质就发生变化了. 识别系统的目的。 系统有一个目的或者初衷。比如学校的目的是教书育人而不是从事商业化活动. 有些系统的目的不是很明显。比如一个生态，它的目的就是活下来。 总结 分解是无处不在的思想， 具体落实到每个实际领域的时候，需要找到这个领域的层次和维度. 分解给我们的带来的一个启示是： 如果一个系统是可被分解的，那么它一定是可以被理解的。 如果一个系统是可以被理解的，那么它一定是可以寻求最优解的。]]></content>
      <categories>
        <category>认知</category>
      </categories>
      <tags>
        <tag>认知</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据，信息，知识和智慧]]></title>
    <url>%2F2020%2F09%2F10%2Fdata-knowledge%2F</url>
    <content type="text"><![CDATA[网络上有一副有名的图片，形象的描述了数据，信息，知识，智慧的大体关系. 下面简单的谈谈我对这幅图片的个人理解. 数据 信息 知识 智慧 数据 一般而言， 数据是我们观察到的或者看到的现象. 程序的日志 每天的步行记录 太阳升起了 数据是属于事实层面的东西。数据没有真假，不管你相信不相信， 它就在那里. 信息 信息是对数据进行的简单加工. 每天步行的数量， 再加上时间，可以计算出上午步行了多少步，下午步行了多少步. 那么这就是一段信息 菜谱 两人之间日常的交流 软件的安装手册 新闻报道 一篇耸人听闻的文章，比如《太强了，2020最新Java核心知识点整理，超全!》 一个谣言或者情报 代码库 我们日常生活中接触到最多的就是信息。信息有真假和对错之分。比如头条上的文章，有不少是标题党，是垃圾信息. 所以学会鉴别垃圾信息很重要， 可以减轻大脑的负担， 让生活做减法， 做到断舍离.根据二八法制，生活中真正有用的信息只有20%. 特点 适合解决某个具体的问题。 结果是可以量化的和感知的。 不具备通用型. 知识 知识是对数据的再加工，知识更多的是属于观点。 从上面的步行数据，发现这个人每天步行数有2万步， 可以推断这个人是一个勤劳的人。 这就是一个知识 牛顿的三大定律 各个学科的模型 做事的套路或者最佳实践 思维框架 知识一定是表达了一个观点或者主题。它可以解释世界以及可以更好的指导实践。 根据二八法则， 对自己有用的知识只有20%.代表性的书籍 《设计模式》 《模型思维》 特点 适合解决某一类问题 往往要结合上下文具体情况具体分析 智慧 智慧严格来说，是知识的一种，也属于一种观点，普适性较强，是老祖宗的长期实践总结下来的知识。 哲学。 否极泰来 塞翁失马，焉知非福 以人为本 代表性的书籍 《程序员修炼之道》 《周易》 特点 适用于时间跨度长的事情 适用于规模比较大的组织 比较灵活 效果很能被直接感知和量化 总结数据属于事实。信息，知识和智慧属于观点。数据的终极使命是形成智慧。数据，信息，知识，智慧都属于知的范畴。知是起点， 知的终点是行.数据 -》信息-》知识-》智慧， 这是一个熵简的过程。我们在求学的过程中， 就是不断读书，形成观点的过程。我们在工作中就是在不断梳理和整合信息，形成观点和解决问题的过程。这是一个无序到有秩序的过程。这是一个需要长时间精细加工的过程。这是一个从无价值到有价值的过程。这是一个从低维到高维的过程。这是一个从具体到抽象的过程。最后最重要的是， 当我们看文章，或者刷微博，或者和别人交流的时候，要能鉴别出什么是有用的数据，什么是有用的信息，什么是有用的知识，什么是智慧]]></content>
      <categories>
        <category>认知</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端发展史]]></title>
    <url>%2F2020%2F09%2F07%2Fhistory-of-frontend-development%2F</url>
    <content type="text"><![CDATA[一般来说， 当我们说到前端， 往往是说Web端， 在某些公司， 有大前端的概念， 包括移动端.整个前端发展史可以分为 农耕时期 工业化时期 信息化时期 智能时期 农耕时期 我不打算从第一个网页诞生的时间开始说起， 让我将时间线拉到2000年左右。 在这个阶段， 做的最好的网页就是搜狐，新浪，网易之类的门户网站。 在这个阶段的技术比较粗燥， 也没有什么交互行为， 就是登陆站点，查看信息。 要设计一个页面， 最简单的方式就是拖拉，Dreamweaver可以做到， Asp也可以做到， 桌面端的VB, Winform也支持拖拉行为。 也没有设计网页有个什么规范或者模式的说法。对比同时期的Spring的概念，比如 AOP, DI. 前端真的太寒碜了。 工业化时期 这个阶段开始的标志性事件是2005年出现的Ajax, 它直接将用户体验提升了一个档次. 再后来是2006年出现的Jquery, 彻底颠覆了前端的开发方式，特别是以Jquery为核心的生态的蓬勃发展。Jquery在前端界的地位比不上Spring在Java届的地位, 但接近半个Spring。 前端发展史里面有一条线就是模块发展的历史 2005年左右Ajax 2006年左右Jquery 模块化 requirejs commonjs node 2009年 信息化时代 规范化 es6 html5 组件化 webcomponent 工程化 webpack TypeScript 智能化时代]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件设计原则]]></title>
    <url>%2F2020%2F09%2F06%2Fdesign-principle%2F</url>
    <content type="text"><![CDATA[在设计软件模块的时候， 我们往往会遵循一些原则， 这些原则五花八门，有的是来自于面向对象领域， 有的是来自于纯设计领域。 有些原则在某些场景下会不灵光。 这篇文章主要就是聊聊这些原则。在这里， 我将软件设计原则分为三类。 总的原则 通用的原则 特殊的原则 总的原则没有银弹通用的原则分离关注点正交原则好莱坞原则单一职责/科里定律DRYKISS最少知识原则/别让我思考最小惊讶原则YAGNI-不要过度/三适里面的适度童子军原则特殊的原则命令与查询分离组合优于继承约定优于配置依赖倒置里氏替换接口隔离开闭原则共同封闭共同重用封装经常修改的代码The Rule of Three总结如果将一个软件看做一个系统的话，那么这些原则最终的目的是让这个系统达到一个平衡。 在满足系统目的的前提下， 实现方式尽可能的简单， 尽可能的简单是控制复杂度的另外一种表述。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一种可以衡量事物的指标-快和好]]></title>
    <url>%2F2020%2F08%2F30%2Fgood-quick%2F</url>
    <content type="text"><![CDATA[在生活中我们会遇到各种不同的事物, 比如一辆汽车, 一部电影, 一本书, 一个技术, 一个大型项目, 一家公司, 这些事物都是处于不断的发展当中, 并且有着自己的阶段性形态或者终极形态. 有没有一种简单的方法来衡量一个事物?这里有两个指标可以衡量一个事物 好 快 好这里的好意味着正确的结果, 高的质量, 一个事物好到极致就是一件艺术品. 所以好最基本的要求， 就是一个事物的结果至少是对的。 另外好是一个主观性比较强的指标. 一段代码易懂而且没有Bug, 容易扩展, 耐操, 那可以说这段代码是好的代码. 一个框架使用起来简单,没有侵入性, 遇到问题社区里有相应的解决方案, 可以说这是一个好的框架. 好在架构层面可以理解为高可用，可扩展 一个产品解决了用户的痛点问题, 提升了用户流量, 那么这是一个好的产品. 一个组织有愿景, 始终以正确的方式在做正确的事情, 那么这是一个好的组织 快快是指限定时间内完成某件事情的度量, 这里是一个独立的维度.人类社会发展过程当中， 隐含了两个发展因素 能量。从钻木取火， 到蒸汽机， 到核能，无疑让事物变的越来越快。 信息。 从甲骨文，羊皮卷， 到印刷术， 再到如今的电脑， 信息传播的速度越来越快。但人脑始终没跟上信息爆炸的速度。快会衍生出下面几个指标: 多 以前一个小时可以完成一件事情, 现在做事情快了之后, 一个小时可以完成两件事情, 相应的产出就变多了. 省 以前一个小时可以完成一件事情, 现在做事情快了之后, 那么完成一件事情只需要半个小时, 就是时间成本降低了. 具体的一些例子 快在架构层面可以理解为高性能 快和好快和好是一对矛盾体,快和好衍生出的另外一个指标就是“成本/收益”, 也可以称作为”性价比“。一个完美的组织应当有正确的目标, 然后以正确而且快速的方式去实现这个目标.但很显然, 现实不是如此.一个创业公司, 做事情讲究的是快, 快速试错, 快速获得反馈, 然后快速调整. 从代码的角度来看, 命名是不是优雅可读? 不重要, 代码需要可扩展性么? 不重要.一顿操作猛如虎, 简单的说, 就是“猛快糙”.一个成熟的公司, 还是拿写代码来说,写代码的时候要考虑到各种各样的情况, 比如以后别人接手你的代码,比人能看懂么? 这个问题可以抽象到什么程度?想起一个伦敦的同事, 偶尔会在群里分享范畴论, 这玩意就是数学领域的知识, 也就是他会尝试去了解数学领域的知识, 在我看来不太实用, 因为大多数开发者是做工程的, 不是做科学的. 如果这个同事去创业公司干活, 估计会很不适应. 总结一个人或者一个组织很难同时做到快和好.一个系统追求的是“成本/收益”最大化，也某些场合可以理解为期望值最大化。或者如果想做到快和好, 就要去合理的定义快和好, 这是一种平衡, 可以用三适原则里的适度来解释. 就拿一个组织来说, 可以尝试着问如下问题: 代码能跑起来是不是意味着好? 框架能用是不是意味着好? 如果能用, 那框架好用么?用起来舒服吗? 一项任务完成之后, 时间有记录么? 平均时间是多少? 这些问题如何能被正确的回答, 每个组织内部就会对好和快有一种感性和直觉的认识.]]></content>
      <categories>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三适原则]]></title>
    <url>%2F2020%2F08%2F29%2Fthree-principles%2F</url>
    <content type="text"><![CDATA[三是我喜欢的数字之一.某个时候, 我想是不是有些原则可以指导学习,工作或者生活呢? 这个原则不必然是根本性, 也不必然是很牛, 我只是想它在大多数情况下是正确的. 于是我总结出三适原则, 和几个朋友交流了一下这个三适原则, 他们对这个原则大多还是比较认可.三适就是 适度(moderate) 适应(adaptation) 适合(fit) 适度 我们常常说”凡事有个度“, “阴阳”, “刚柔并济”, “中庸”,“平衡”, “过犹不及”, “进可攻退可守”，“恰到好处” 差不多就是指这个意思. 为什么适度很有用? 几个例子 一个新人刚刚入职, 肯定是要表现自己的, 加班, 无论什么事都接下来, 领导很满意. 等过了试用期, 领导发现新人表现比之前差, 有点失望了. 这里的问题就在于新人在试用期用力过猛, 领导对他期望值很高, 导致后续乏力, 领导对他失望要很正常. 在NBA里, 有不同类型的球员, 有的暴发力一流, 有的力量一流, 有的三分很准. 但有一类球员, 他是靠节奏取胜的, 他没有爆发力, 也没有力量, 但他运球在该快的时候快, 该慢的时候时候慢, 节奏掌控的很好,代表球员是斯蒂夫纳什. 中国人说话讲究中庸之道, 不把话说太死, 这样说话就有回旋的余地, 这里也体现了灰度思维. 在学习的时候, 不能学习太长, 学习一段时间之后,就要强制休息. 精力分配要适度, 这样才能继续学习提供良好的基础.适应外部环境是在变化的, 作为人是否也要改变来适应这个变化? 一些例子和理论 物竞天择, 适者生存. 这是自然界最基本的规律.生物和生物之间相互竞争, 最终适应环境的生物活下来了,这里蕴含了生态思维和演化思维. 试想一个亚马孙丛林, 没有人去干涉它, 它始终能保证着活水源头, 物种的多样性. 现在开发技术更新的很快, 要不要学习? 答案是要学习, 否则无法适应技术发展的趋势. 但如何学习是另外一个单独的话题 一个软件的架构要适应业务的发展，要有弹性. 应用 阿里技术专家里李运华提出了架构三大原则之一-演化原则。 演化原则和这里的适应原则内涵不谋而合。 适合 这里的适合更多的是强调一种匹配. 几个例子 一把钥匙配一把锁, 因为锁的大小决定了钥匙的大小. 这对情侣真配真合适. 小李很适合做销售. 橘生淮南则为橘，生于淮北则为枳, 什么样的植物适合什么样的土壤. 有些人工作一段时间之后, 会抱怨为什么工作内容这么无聊呢? 也许他没有错, 这份工作也没错, 他只是不适合这份工作而已. 应用 如何用适合这个原则解释康威定律？ 康威定律的大体意思是：软件架构受限于组织架构的沟通方式。简单的说，有 项目组 A和项目组 B, 项目组 A负责数据访问层，项目组 B负责业务逻辑层， 那么业务逻辑层和数据访问层就可以通过RPC进行交互，如果数据访问层和业务逻辑层由同一个项目组负责， 那么就有可能将这两层放在同一个程序集里. 这里的模式是组织架构决定了软件架构， 所以软件架构要适合组织架构。 但有没有可能先定下软件架构，然后让组织架构适应软件架构呢？这是另外一个话题了 阿里技术专家李运华在《从0开始学架构》里面提出了架构的三大原则之一-合适原则：“合适由于业界领先” 总结适应和适合可能会让人感觉差不多, 但适应是一个过程, 适合是适应的结果. 比如张三一开始不能适应这个职位, 但经过一段时间的调整, 最终适应了, 也就是和这个职位匹配了.适度代表了平衡， 适应代表了代表了动态， 所以适度 + 适应代表了动态的平衡.三是一个神奇的数字，一生二， 二生三，三生万物， 我喜欢三.]]></content>
      <categories>
        <category>认知</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何衡量一个人对技术框架的熟练度?]]></title>
    <url>%2F2020%2F08%2F29%2Ftech-proficiency%2F</url>
    <content type="text"><![CDATA[在日常开发中, 作为开发者大多数时间面对的是技术和业务, 在这篇文章里, 我主要想说说作为开发者, 对一项技术应该如何合理的去把握.假象一下, 现在我们要学习一个新的技术框架, 可能是Spring boot也可能是React, 或者是Redis, 我们应该如何切入?现在姑且从三个大的角度对技术的熟练度进行划分 应用 简单场景的应用 复杂场景的应用 设计 框架设计的初衷 框架的核心概念 框架的设计思路 框架的设计模式 框架的设计思想,原则和哲学 实现 核心模块的实现细节 一些模块实现的奇技淫巧 应用简单场景的应用很不幸, 人往往是在框架或者特定的环境下做事的, 长此以往人会形成特定的习惯行为模式,这种特定的习惯会形成一个有陷阱的舒适圈.在实际的工作中, 我们往往知道一个东西是如何使用的就是够了. 比如说这样一个例子, 现在要页面要实现一个新增用户的功能, 基本上需要写存储过程, 写DAL层, 写Service层, 写页面层(包括验证), 然后做相应的测试. 要完成这个例子基本上就是在一个框架下完成的, 每个公司都有自己相应的框架, 不同之处就是名称不一样.在这样的场景下, 我们知道这个api是如何使用的就足够了, 我们也必然会变成一个api熟练工.长此以往, 一年下来如果只是做这种类似的功能, 对自己能力的提升是没有任何帮助的, 换句话说你表面上有的只是一年的经历, 实际上是一个礼拜的经验. 但这事对个人来说只能说是常态, 但对组织来说是必须, 因为一个组织需要的是分工, 分工必然导致一些工作是简单的重复和可替代性, 这种模式下的做事方式是具有可预见性的 复杂场景的应用复杂场景一般是指两种情况 假设有模块A, 由项目组A负责, 模块A会被很多系统调用, 模块A依赖于模块B(项目组B负责), 模块B依赖于模块C(项目组C负责). 这里的复杂度可以细分为两种 模块依赖的复杂度, 这里模块依赖会形成一个有向无环图, 如果是一个团队负责这些所有模块, 那么这个复杂度仅仅存在于团队内部. 如果是不同团队负责不同的模块, 那么就是组织之间沟通的复杂度. 这种类型的复杂度是一种玄学, 往往会伴随着如下名词或短语出现,“集成”,“扯皮”, “等他们数据准备好”, “被他们block住了” 假设模块之间的关系是固定的, 那么随着用户数量的上升, 这个框架在性能方面是否还能扛得住? 量变会引起质变, 在其余什么都不变的情况下,仅仅是用户量的提升, 理论上会导致系统扛不住. 这里会有一个很自然而然的问题, 这个框架或者系统的极限是什么? 遗憾的是, 只有大公司才有会遇到这个问题, 对于大部分公司开发者而言, 是没有这样的实操经验的. 总结在这个层次上，我们所需要就是会用就可以了，至于为什么要这么用，就不是很清楚了. 还真别说，这招在中小公司很管用. 设计框架设计的初衷框架的核心概念框架的设计思路框架的设计模式框架的设计思想, 原则和哲学实现核心模块的实现细节一些模块实现的奇技淫巧]]></content>
  </entry>
  <entry>
    <title><![CDATA[牛刀小试]]></title>
    <url>%2F2019%2F07%2F04%2Fnew-place%2F</url>
    <content type="text"><![CDATA[一直有想写博客的想法，因为各种原因不了了之，也许是搭建博客是太麻烦了。后来看到一个朋友是用Hexo搭建了博客，看上去不错，自己就尝试一下。于是，便有了这个站点。 以前看见好的帖子或者文章会收藏在印象笔记, 相比于印象笔记，博客的优势就体现在如下方面： 这是一种输出,输出是一种结果，结果可以引申为某种目的和愿景。在很多场合下，人往往会听到学以致用，知行合一，包括以终为始的习惯，还有什么费曼学习法，都是暗含了输出的思想。 可以让别人来评论，从而带来观点的传播,交流和融合.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Welcome]]></title>
    <url>%2F2019%2F07%2F02%2Fwelcome%2F</url>
    <content type="text"><![CDATA[Hello, Welcome to Ricky World!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
